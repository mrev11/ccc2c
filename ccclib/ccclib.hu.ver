
2016.04.14 szignal maszkolas
  Korabban csak  CCC szintu "maszkolas" volt.
  A sigcccmask-ban beallitott szignalokat a CCC handler 
  egyszeruen ignoralta. Ilyenkor a rendszer ugy veszi, 
  hogy a szignal kezbesitve volt (ugy elintezve). Ezzel 
  szemben, ha a maszkot a rendszer szintjen is beallitjuk,
  akkor a rendszer olyan szalat keres, ami nem maszkolja
  az adott szignalt, es ha talal ilyet, akkor ez a szal
  kapja meg a szignalt. Tehat kaphatunk olyan szignalokat,
  amik korabban elvesztek.
  
  thread.cpp-ben javitva a szignal maszk oroklodese.
  sigprocmask helyett pthread_sigmask-ot kell hasznalni.

  signals.cpp, thread.cpp, thread_data.h atvive CCC2-be.


2015.09.24 week() implementacio
  week() -> 1-53, het sorszama az evben, CA-Tools 
  isoweek() -> 1-53, het sorszama az evben, ISO kompatibilis 
  isleap() -> .t./.f., szokoev, CA-Tools 


2014.07.26 Szemetgyujtes (variable.cpp) atveve CCC3-bol.
  A CCC3 szemetgyujtese a fabejarashoz nem rekurziv fuggvenyhivast 
  hasznal, hanem egy kulon stacket (nincs kiteve stack tulcsordulasnak). 
  Kevesebbet hasznalja az ertekek tipusat,  ezert (talan) biztosabban
  keruli el a tobbszalusag buktatoit.
  A CCC3 szemetgyujto programja lett visszaegyszerusitve:
    - nincs X tipus
    - az oref-ben nincs age tag -> nem szamolja az objektumok korat
  A szemetgyujto program csereje megkoveteli, hogy a string oref-ekben
  a length tag ugyanugy legyen hasznalva, mint CCC3-ben:
    oref->length = 0  a memoria objektumot nem szabad torolni
    oref->length < 0  a memoria objektum torlendo (de nincsenek benne VAULE-k)
    oref->length > 0  a memoria objektum torlendo (VAULE-k vannak benne)
  Az oref->length-re vonatkozo modositast akkor is celszeru megcsinalni,
  ha nem csereljuk a szemetgyujto programot.

2014.01.29  str.cpp ujrairva.
  str.cpp: vedekezes -0 ellen.
  pushcall.cpp: stack overflow elleni vedelem javitva.

2014.01.25 malloc.h megszuntetve
  <malloc.h> (depracated) mindenhol <stdlib.h>-ra cserelve
  setup-unix keszlet frissitve

2013.10.09
  breakblock()

2011.09.19
  localstack() return értéke derefelve.

2011.06.28
  stvar.cpp: buffer overflow ellenõrzés, dupla helyfoglalás megszüntetve.

2010.11.08

  A string változók hossza unsigned int helyett unsigned long.

  Az új STRINGPTR makró ellenõrzi chrptr!=0-t, és PTRERROR-t dob, ha null,
  tehát normális runtime error keletkezik, ha a progam (tévesen) használni
  akar egy lezárt mapot.

  A MAXSTRLEN korlátokat a string.cpp modulban ellenõrizzük, amikor 
  a memóriabuffer létrejön. A string.cpp modul függvényei unsigned long 
  paramétert kérnek (a korábbi int helyett) a régi változatok meg vannak 
  tartva a kompatibilitás érdekében. Néhány  esetben a hossz számításakor 
  túlcsordulás lehet, az ilyen helyeken az összetevõket elõzõleg ellenõrizni 
  kell, pl. add, replicate.

  Offset paraméterek.
  Az offset paraméterek a programban akármilyen (negatív/pozitív) értéket 
  kaphatnak, de csak 1-tõl a tömb maximális méretéig terjedõ
  értékeket lehet elfogadni. Korábban jó volt a sima _parni vagy _parnu
  paraméterátvétel. Most azonban a lehetõ legnagyobb pozitív (unsigned)
  értéket is kezelni akarjuk, ezért külön le kell választani azt az
  esetet amikor az eredetileg double típusú paraméter értéke negatív.
  Példa a binary string indexelése:
    unsigned long len=BINARYLEN(a);         // hossz
    double dx=i->data.number;               // offset
    unsigned long idx=dx<0?0:D2ULONG(dx);   // index: negatív->hiba, pozitív->ulong
    if( idx<1 || len<idx )
    {
        error_idx("idxr",a,2);
    }
    BYTE c=BINARYPTR(a)[idx-1];

  Makrók unsigned és signed összehasonlítására: GTUS, GEUS, minUS, maxUS.

  Változott

    add.cpp add():
        összeadandók hossza külön-külön is nézve (túlcsordulás ellen)
        C típus hossza unsigned long

    array.cpp idxr() idxr0():
        unsigned long idx=dx<0?0:D2ULONG(dx);
    
    at.cpp:
        unsigned long tlen=_parclen(2); //ebben keresunk
        double dstrt=ISNIL(3)?0:_parnd(3)-1;
        unsigned long strt=dstrt<0?tlen:D2ULONG(dstrt); //innen kezdve keresunk

    base64.cpp:
        unsigned long hosszak
        maxhossz ellenõrzés

    empty.cpp:
        unsigned long hosszak

    equalto.cpp:
        unsigned long hosszak
    
    errorgen.cpp:
        void error_nul(const char *operation, VALUE *base, int argno)

    fileio.cpp:
        unsigned long hosszak

    pad.cpp:
        unsigned long hosszak
        MAXSTRLEN ellenõrzés kivéve
        CCC3 implementáció átvéve

    rat.cpp:
        unsigned long hosszak
        (!)az unsigned long ciklusváltozó miatt másképp jár a ciklus
        CCC3 implementáció átvéve

    replicate.cpp:
        unsigned long hosszak
        maxhossz ellenõrzés double-ban kiszámított értékkel!
        CCC3 implementáció átvéve (külön modul)

    slice.cpp:
        unsigned long idx;
        idx=i->data.number<0?0:D2ULONG(i->data.number);
        
    string.cpp:
        maxhossz ellenõrzések
        unsigned long paraméterezés

    stuff.cpp:
        unsigned long hosszak
        maxhossz ellenõrzés a bemenõ stringre
        (!)nsta eggyel hosszabb lehet, pl. stuff("a",2,0,"b") -> "ab" 
        CCC3 implementáció átvéve
        
    substr.cpp _clp_substr(), _clp_left(), _clp_right():    
        unsigned long hosszak
        substr()-ben dbeg +/- esetei szétválasztva
        CCC3 implementáció átvéve

    trim.cpp:
        unsigned long hosszak

    varprint.cpp:
        a chrptr==0 stringeket kikerüli, "(null)"-t ír helyettük

    vmm.cpp:
        unsigned long hosszak (sok helyen)
        64-biten xvputbin alkalmas nagy filék írására 
        CCC3 implementáció átvéve
 


2010.11.04
  exec() és spawn() vizsgálja az array paraméter elemeinek típusát,
  és ARGERROR-t dob, ha rossz típust talál. Korábban ezekben SIGSEGV
  fordulhatott elõ.
  
  stuff(cstr,nstart,ndel,cins)-ban nstart max értéke len(cstr)+1
  (korábban tévesen len(cstr) volt). Pl. stuff("a",2,0,"b") --> "ab".
  
  chsize _parnu()-val veszi át a paraméterét.

  STRINGPTR0 makró megszûnt (helyette STRINGPTR).
  STRINGPTR makró változott, nem vizsgálja az oref!=0 feltételt.
  Régen volt olyan elgondolás, hogy a 0 hosszúságú stringeknek
  nincs kötelezõen memóriabufferük, és ezért nincs feltétlenül oref-jük.
  A stringeknek azonban mindig van orefjük, ami onnan tudható, 
  hogy minden string a string.cpp modulban levõ néhány függvénnyel 
  készül, és ezek mindig legyártják az oref-et.
  
  Inverz makró helyettesítés. 
  Van néhány ilyen makró (közte néhány új):
    #define STRINGPTR(v)   ((v)->data.string.oref->ptr.chrptr)
    #define ARRAYPTR(v)    ((v)->data.array.oref->ptr.valptr)
    #define STRINGLEN(v)   ((v)->data.string.len)
    #define ARRAYLEN(v)    ((v)->data.array.oref->length)
  Ezek a régi programokban nem voltak egyöntetûen használva.
  Egy programmal az összes lehetséges helyre beírtam a makró baloldalát.
  Ellenõrzésképpen bináris cmp-vel összevetésre kerültek a transzformáció 
  elõtti és utáni forrásokból készített objectek, nem keletkezett eltérés.
  

2010.05.25
  Újraírt time.cpp modul, ctime.cpp megszûnt.

2010.04.06
  ignored return value (2008.10.02) javitas javitasa
    0==fwrite() helyett int retcode=fwrite() 
    ui. az MSVC nem fogadta el az elozo valtozatot.
    Ez sok filet erint, a lex fileket is, a flexbeli skel.c-t is.
    Most Windowson ujra hasznalhato az MSVC.

  gcc 4.4.1 warningok kijavitva.  
      
  A main modulok setbinary reszeben:
    if( oldhandle==(long)INVALID_HANDLE_VALUE )
    {
        return; //nincs nyitva?
    }
    ui. ha nincs nyitva, akkor erdektelen a tex/binary mode.
    
  install.b sorrend esszerusitve  
    Rogton a vegleges ppo2cpp-t forditja,
    igy a setup-unix/ppo2cpp kihagyhato.


2010.01.11
  Rossz az elõzõ módosítás, 
    empty(block) visszaállítva a korábbi állapot: mindig .f.
    len(block) megtartva az új értelmezés (refes változók száma)

2009.12.29
  len() es empty() kiterjesztve:

  len(object)   <-> attributumok szama
  empty(object) <-> attributumok szama nulla
  len(block)    <-> blockvaltozok szama       (2010.01.11 megtartva)
  empty(block)  <-> blockvaltozok szama nulla (2010.01.11 ROSSZ!, visszavéve)

  Mindig problema, hogy a kulonbozo tipusok ures peldanyaihoz keszul-e oref, 
  es az oref-hez tartozik-e buffer. Az alabbi tablazat mutatja az eseteket. 
  YES=mindig, ?=ha nem ures, (YES)=ha van oref.

           |   oref  buffer
    -----------------------
    string |   YES    YES 
    binary |   YES    YES
    array  |   YES     ?
    object |   YES     ?
    block  |    ?    (YES)

  Javitva == es != objektumokra es blockokra:

    obj1==obj2 <-> ha oref1==oref2 es subtype1==subtype2
    blk1==blk2 <-> ha oref1==oref2 es code1==code2

  Korabban a subtype-ok es code-ok egyezoseget nem nezte.

2009.11.30
  class.prg   : runtime error, ha a metodus cast attributumra vonatkozik
  valtype.cpp : valtype(@x) erteke "U" (a korabbi "" helyett) 


2009.01.20
  bovitett simplehash osztaly

2008.12.10
  szalkezeles javitva 
    VALUE::operator=(VALUE v)-ban es add()-ban.

2008.12.10
  delete -> DELTHRDATA
  closeonexec/sethandleinheritflag egysegesites
  SIGABRT kezeles
  Solaris es FreeBSD javitasok

2008.10.02
  gcc 4.3.2 warningok javitva.
  
  1) warning: ignoring return value

    eredeti:
        fwrite(BINARYPTR(TOP()),1,len,outfile[x].fp);
    javitas:
        0==fwrite(BINARYPTR(TOP()),1,len,outfile[x].fp);

2008.08.19
  at()-ben SIGSEGV hiba javítva.
  
2008.05.23
  gcc 4.3.0 warningok megszüntetve

2008.04.30
  3 paraméters at() áthozva a CCC3-ból
  sat() megtartva a kompatibilitás céljából

2008.03.13
  slice.cpp korszerûsítve

2008.03.05
  stringek indexelhetõek -> karakter
  string szeletek

2008.02.22 -- 2.3.12
  simplehash osztály -- asszociatív tömb

2008.02.03 -- 2.3.11

  Rossz volt Windows XP-n a socket.inherit implementáció.
  Windows 2000-en a DuplicateHandle-es megoldás jól mûködött.
  XP-tõl kezdõdõen viszont a DuplicateHandle nem alkalmazható socketekre,
  hanem helyette a Set/GetHandleInformation-t kell használni.
  Erre épül az új windows/closeonexec.cpp modul:

    sethandleinheritflag   //használható socketre
    gethandleinheritflag   //használható socketre
    setcloexecflag         //nem használható socketre
    getcloexecflag         //nem használható socketre

  A set/gethandleinheritflag csak Windows HANDLE-ekre mûködik.
  A set/getcloexecflag Windowson csak POSIX leírókra mûködik.

  A set/getcloexecflag file- és pipe-leírókra UNIX-on és Windowson 
  egyformán mûködik. UNIX-on ezenkívül a set/getcloexecflag socket 
  leírókra is mûködik.

  A C szintû main-ekben az 1,2 fd átállítva binary módra.
  (Mi van a 0-ás fd-vel?)

  Küzdelem a const char * típusokkal.

2008.01.19 -- 2.3.10
  class.prg áthozva CCC3-ból 
  attr->meth felüldefiniálás javítva

2007.10.31 -- 2.3.09
  A src/syserror subdirectory megszûnt, 
  helyette az error-osztályok definíciója áthozva CCC3-ból. 
  Ennek megfelelõen módosítva: ccc.bld, ccc.bldnt.

2007.09.11 -- 2.3.08
  UNIX-os curdir() javítva, kivéve a kezdõ dirsep.
  A curdir használat átnézve, és ahol kellett a curdir
  dirname-re cserélve, aminek értelmezése: dirsep+curdir.

2007.07.04 -- 2.3.07
  A 2006.08.03-es javítás a str(n) konverzió minimális 
  10 mezõszélességét 9-re rontotta. Visszaállítva 10-re.

2007.03.06 -- 2.3.06
  Uj FO_APPEND/FC_APPEND nyitasi mod fopen/fcreat-ban.

2007.03.01 -- 2.3.05
  Új warningok kipucolása az uif könyvtárból.

2007.02.12 -- 2.3.04
  directory("/*","D") nem mûködött.

2006.08.03 -- 2.3.03
  str hibája nagy számoknál javítva.

2006.01.23 -- 2.3.02
  qout.cpp-be visszatéve a karakterkonverzió.

2005.11.04 -- 2.3.01
  DOSCONV defaultja 0.
  ppo2cpp-ben 'to' és 'step' nem lehet függvénynév.
  Windowson piros X helyett zöld pipa.
  xmethod2-ben üres virtuális destructor.
  Null argument warningok elhárítva.

2005.07.31 -- 2.3.00
  Az új objectek nem linkelhetõk a régiekkel, 
  tehát átálláskor egyszerre mindent újra kell fordítani.

  Kivételkezelés
    Struktúrált kivételkezelés: több recover, amik típus alapján
    válogatnak a kivételek között, új finally ág, mindez Jáva mintára.
    A ppo2cpp a 4.3.00f változattól kezdve fordítja az új szintaktikát.
    Recover nélküli break kilépés helyett kiértékeli az errorblockot.
    A könyvtárakban eval(errorblock(),e) helyett break(e).
    Különféle error leszármazottak syserror-ban.
    Az object osztályban új metódus: isderivedfrom.
    Prototype objectek.

  Táblaobjektumok 
    A hibakezelés a fentieknek megfelelõen változott,
    speciális hibaosztályok: tabStructError, tabIndexError.

  Szignál kezelés
    signal.ch-ban egységesen használt signum konstansok.
    Mutex lockok alatt a szignálok tiltva (deadlock ellen).
    Windows ctrlcblock megszûnt, setposixsignal átalakítva.
    Szignálok blokkolása Linuxon és Windowson egységesítve.
    signalblock paraméterezése változott: eval(signalblock(),signum).
    Szálak indításakor védekezés a szignálok ellen.
    siglocklev, sigcccmask öröklõdik a szálak között.

    Új szignál API: 
        signal_description, signal_lock, signal_unlock,
        signal_raise, signal_send, signal_pending, signal_clear, 
        signal_setmask, signal_mask, signal_unmask.

  Megjegyzés a szignálokhoz
    A szálbiztonság és a korrekt szignálkezelés legfontosabb
    kritériuma: Minden olyan pillanatban, amikor egy másik 
    szálból szemétgyûjtés indulhat, vagy a szál szignált kaphat 
    a vermeken kell legyen minden élõ változó, de nem lehet 
    ott semmi más (pl. megszûnõben levõ változók). E kritérium
    teljesítése csak a ccc2 és ccc2_ui_ könyvtáraknál kitûzött cél.
    Ha egy nem szálbiztosan megírt program a szignálkezelõben 
    szemetet gyûjt, akkor továbbra is elõfordulhat elszállás.
    A CCC alap futtatórendszere (ccc2 és ccc2_ui_) a szignálkezelés 
    alatt is ép állapotban tartja a változóteret, és elkerüli 
    a deadlockokat.  A reentráns programoknál szokásos általános
    szabályokon kívül semmilyen tiltás nincs, elvileg  bármi
    futhat a szignálkezelõben.

    A signal_lock(), signal_unlock() API csak azt a szálat védi
    a szignáltól, ami a signal_lock()-ot meghívta. Ettõl még bármely
    másik szál kaphat SIGINT-et, és az egész program kiléphet.
    Windowson éppenséggel mindig ez a helyzet, ui. a SIGINT-et
    mindig egy újonnan induló szál kapja. A signal_lock() ezért
    csak arra való, hogy a mutexeket védje deadlock ellen.
    Ha az egész programot kell védeni a SIGINT-tõl akkor ki kell
    cserélni a minden szálra globális signalblock()-ot. Így
    mûködik az új setposixsignal().

  Castolások
    Összes (char*) cast felülvizsgálva.
    Összes (char *) cserélve (char*)-re, hogy könnyebb legyen keresni.
    const char* deklarációk, ahol az lehetõvé teszi a (char*) kihagyását,
    pl. char *txt=(char*)YYText() helyett const char *txt=YYText().
    strings(), stringn() char* helyett const char*-t vár.
    
  Megjegyzés a castoláshoz
        char *buf="string literal";
    régi értelmezése: inicializált karakterbuffer,
    új értelmezése: karakterkonstans (readonly szegmensbe helyezve).
    Korábban a -fwritable_strings opcióval választható volt
    a régi értelmezés, most azonban ez az opció a GCC-ben megszûnt.
    A string literál helybeni nagybetûre konvertálása SIGSEGV-t okoz.
    Ha a C++ logikus akarna lenni, akkor a fenti sorra hibát kéne
    jeleznie. Ehelyett a C++ tervezõjének két kötetes,  1000 oldalas 
    könyvében azt olvasom: A sok régi programra való tekintettel (!) 
    a fordítók a fenti sort warning nélkül fogadják el. Következmény:
    Az inkompatibilis változás miatt, és amiatt, hogy az új C++ szabvány 
    következetlenül használja a char* és const char*  típusokat, régi 
    C programok warning-mentes fordítás után SIGSEGV-znek.
    
  Szemétgyûjtés, szálbiztonság
    A szemétgyûjtés és a VALUE értékadás szinkronizálásában
    a vitatott zsilipelés helyett szálanként privát mutexek lockolva.
    A nem szálbiztos *stack++=NIL helyett mindenhol PUSHNIL().

  Egyéb
    Build, prg2ppo, z, zgrep statikusan linkel.
    sread()-bõl kivéve az 1 órás timeout.
    Stack kezelési hiba javítva evalarr()-ban.
    asort()-ban az összehasonlító block alatt gc engedélyezve.
    Egyes include filék több példányban tárolása megszûnt.
    Run és quit preprocesszálása megszûnt.
    waitpid() WNOHANG módja javítva.


2005.04.26 -- 2.2.02
  push_call makró helyett függvény, ellenõrzi a stack overflow-t.

2005.04.07 -- 2.2.01
  Portolás (i386-os) FreeBSD 5.3-ra.
  FreeBSD-n külön installálni kell /bin/bash-t.
  FreeBSD-ben (GCC 3.4.2-ben?) nincs malloc.h, csinálni kell.
  Nincs libdl.so könyvtár (link.opt-ból kihagyva).
  Linkeléskor meg kell adni a -rpath-link opciót.

  GCC 3.4.2-ben a -fwritable-strings opció deprecated lett,
  ezért mindenhol be kellett írni: (char*)"".
  
2005.01.24 -- 2.2.00
  Portolás 64-bitre (x86-64/amd64 kompatibilitás).
  Új Clipper típus: P. Azokon a helyeken, ahol a C réteg 64-bites
  mennyiséget adott át számváltozóban a Clipper rétegnek, a számváltozó
  helyett áttértünk az új P típusra.
  
  A CCC alaprendszer és alkalmazások egyformán fordulnak és 
  futnak 32 és 64-bites gépeken (nem kell foglalkozni a bitszámmal). 
  A Ctree rekordkezelõnek azonban nincs 64-bites változata.

2005.01.19 -- 2.1.03
  Hibajavítás sat-ban.
  A korábbi változat nem védekezett negatív kezdõindex ellen.
  
  Alkalmazkodás scrollozó Windows konzolokhoz. 
  Most nem az egész képernyõbuffert vesszük teljes képernyõnek 
  (ami igen nagy lehet), hanem alkalmazkodunk a látható méretekhez 
  és pozícióhoz.
  
  Védekezés a begin és recover között levõ exit/loop/return ellen.

  Új string literál szintaktika: <<SYM>>raw string<<SYM>>


2004.10.31 -- 2.1.02
  uic_ könyvtárbeli inkey-ben paraméterátvétel _parnd-vel.

  Szálbiztonság:
  threadid paraméterek átvétele _parnu-val (a hibás _parni helyett).
  Windowson a MUTEX_LOCK és MUTEX_UNLOCK makrók törzse fel volt 
  cserélve, azért Windowson nem mûködtek a többszálú programok.
  UNIX-on a thread indításnak mutex védelem alatt kell mennie.
  array() veremkezelése javítva.

2004.08.05 -- 2.1.01

  stvar-ban a ststack-hoz való hozzáférés szinkronizálva.

  Támogatva az alábbi inicializálás:
    function hopp(a)
    static x:=proba(a)
  Az inicializátornak át kell adni VALUE*base-t.
  
  Ehhez az stvar osztálynak lett egy stvarloc nevû leszármazottja, 
  ami a base-t is átveszi. A külsõ static változók továbbra is stvar 
  osztályúak, ami nem változott. 
  
  Külsõ static változók szinkronizált létrehozása.
  Az osztályregisztrációk átírása szinkronizáltra.
  
  Makrók: MUTEX_CREATE(x), MUTEX_LOCK(x), MUTEX_UNLOCK(x).


2004.07.17 -- 2.1.00
  Osztály<->metódus párosítás hash táblával:
  
  Az új hashcode.cpp modul hash kódot számol egy viszonylag 
  rövid stringbõl, pl. egy metódus- vagy változónévbõl. 
  
  Az újraírt class.prg modul egyszerû tábla helyett hash táblában 
  tárolja a metódusokat. A hash algoritmus (CCC-ben) pofonegyszerû,
  kevés plusz helyet igényel, és már a hash tábla felépítése
  is gyorsabb, mint a lineáris kereséssel mûködõ egyszerû tábláé.
  A hash tábla kitöltöttsége 1/3 és 2/3 között van, a nem kitöltött 
  helyeken NIL van.

  Az új ppo2cpp 4.0.01+ fordító _method_ helyett _method2_ osztályú 
  metódusobjektumokat fordít, ezek tárolják a metódusnév hash kódját. 
  A _method2_ osztályt az új xmethod2 modul definiálja.  A korábbi 
  _method_ ostály is megmaradt a kompatibilitás érdekében.
  
  Átálláskor nem szükséges az alkalmazási programokat újrafordítani, 
  ui. a korábbi xmethod modul az újra nem fordított (vagy kézzel kódolt) 
  metódusokat a korábbi módon kezeli. A kézzel kódolt metódushívásoknál
  mindenhol célszerû áttérni a DEFINE_METHOD makróra, ennek új változata 
  már _method2_-t fordít.

  A korábbi egy elemû osztály-cache változatlanul megmaradt, és továbbra 
  is ennek köszönhetõ a legnagyobb gyorsulás. Egy egyszerû browse-olós 
  program esetén ilyen futási eredmények  adódtak:
  
    optimailzálás   futásidõ
    semmi                118
    csak hash             16
    csak cache            11
    cache és hash         11
  
  Látható, hogy a cache nagyon hatékony, ha egy modulban egy adott 
  metódust mindig ugyanolyan objektumra alkalmazunk. Valójában ilyenkor 
  a hash táblának kevés haszna van.  Abban az esetben azonban, amikor 
  egy metódust hol ilyen, hol olyan osztályú objektumra alkalmazunk, 
  a cache nem mûködik, és ezért a metódust újra meg újra elõ kell keresni.
  Ilyen eset pl., amikor különféle típusú tranzakció objektumok feldolgozó 
  metódusát hívogatjuk egy ciklusban. Ezt kezeli jól a hash algoritmus.

  Összefoglalva: a hash algoritmus kis mértékben gyorsítja a programok
  elindulását, mert a metódustábla felépítése és a cache-ek elsõ feltöltése
  gyorsul. Megoldja továbbá a cache által kezelhetetlen (ritka) eseteket.
  Van olyan program, amiben a hash optimalizálás 3-szoros gyorsulást ad.


2004.03.30 -- 2.0.11
  Memóriaszivárgás javítva asize-ban.
  Max get template size 256 helyett 1024.

2004.02.20 -- 2.0.10
  Windowsos spawn-ban dinamikus helyfoglalás.
  fcreate, fopen: FO_CREATE, FO_TRUNCATE, FC_NOTRUNC

2004.01.20 -- 2.0.09
  Új függvény: chsize(fd,length).

2004.01.05 -- 2.0.08
  thread_exit elfelejtette megszüntetni a local stacket.

2003.12.31 -- 2.0.07
  ui_ kiegészült az rconsole modullal, 
    hogy le lehessen kérdezni az aktuális megjelenítõt.
  ui_ kiegészült a wstatid modullal, 
    mert a hiánya akadályozta a Kontó linkelését.
  Az uid-ben használt symbols.h frissítve.
  tbwrapper csak akkor tölti be az interaktív komponenseket, 
    ha az aktuális megjelenítõ driver nem ui_.

2003.11.25 -- 2.0.06
  A borlandos dup() hibásan áttér O_BINARY-ról O_TEXT módra,
  ennek elkerülésére beállítva a default O_BINARY mód.

2003.10.19 -- 2.0.05
  Portolás GCC 3.3-ra (sorvégek)
  Windows spawn-ban paraméterellenõrzés javítva.
  UNIX spawn-ban a várakozás javítva.
  fdup bõvítve, új függvény hdup (DuplicateHandle).
 
2003.10.03 -- 2.0.04
  vmm.cpp áthozva a gyökérbe (általános hibakezelés)
  exec Windowson is

2003.09.22 -- 2.0.03
  kombinált spawn, kombinált exec;
  spawn implementáció UNIX-ra;

  UNIX-on waitpid defaultja változott:
    waitpid(pid,@status,1) //régi default (WNOHANG)
    waitpid(pid,@status,0) //új default (várakozik)
 
2003.09.16 -- 2.0.02
  új API : fdup(fd,inherit) (UNIX, Windows)
  új API : setcloexecflag(fd,flag), getcloexecflag(fd) (UNIX) 
  Közös  : chmod.cpp, stat.cpp

2003.09.02 -- 2.0.01
  fclose elírása javítva.

2003.09.02 -- 2.0.00
  A webre kirakva. 

2003.07.25 -- 1.6.09
  Javított tempfile() implementáció.

2003.07.20 -- 1.6.08
  UNIX: fork, waitpid, exec, fdup, setcloseonexec, pipe.

2003.03.07 -- 1.6.07
  scanf hívása elõtt a kimeneti változók mindenhol inicializálva.

2003.03.05 -- 1.6.06
  Javítás stod-ban: Solarison másképp mûködik a scanf.

2003.02.09 -- 1.6.05
  Windows savescreen hibakezelése javítva.

  A Windows nagy ScreeBufferSize beállítása esetén nem tudja
  végrehajtani a ReadConsoleOutput WIN32 API függvényt.
  Most a SIGSEGV-t elkerüljük, és normál hibakezelés történik.
  Korábban a hiba nem fordult elõ, mert NT-n ScreenBufferSize 
  defaultja 25x80 volt, Windows 2K-n viszont 300x80.

  Az alábbi bekezdést át kell másolni egy console-size.reg
  nevû filébe, és betölteni a registrybe:  
  -------------------------------------------
  REGEDIT4
 
  [HKEY_CURRENT_USER\Console]
  "ScreenBufferSize"=dword:00300050
  "WindowSize"=dword:00300050
  -------------------------------------------

2003.01.11 -- 1.6.04
  gcc 3.x kompatibilitás:

    2.96-nál kisebb verziószámú gcc-k használata esetén a not() 
    függvény visszakerült az alapkönyvtárba. A gcc a 2.96-tól
    kezdve ezt nem fogadja el, mert a not-ot és még pár új dolgot
    (or, and,...) kulcsszóként kezel. A not befordítását, vagy
    kihagyását makróval szabályozzuk. A gcc verziószámát a gccver.b
    script állapítja meg, és a megfelelõ #define makrókat kiírja
    a $CCCDIR/usr/options/lin/gccver.opt filébe. A build automatikusan
    futtatja gccver.b-t, ha az opt filé még nem létezik, ha viszont
    létezik, akkor használja a meglevõt. A gccver.opt filét ki kell 
    hagyni a mentésbõl és az installációs csomagok készítésébõl.

  NL_TO_CRNL konverzió a konzol kimeneten.

2002.12.19 -- 1.6.03
  Új modul: fflush.cpp
  clpfilio.cpp-ben determineUnixShareMode() javítva.

2002.11.28 -- 1.6.02
  flgui brwRestore javítva.

2002.11.21 -- 1.6.01
 
  Ezeket az opciókat a gcc 3.2 nem fogadja el:
    -m486
    -malign-jumps=4
    -malign-functions=4
  ezért kimaradtak.

  A Large File Support (LFS) beállítása változott:

  LFS bekapcsolva:
    -D_LFS_
    -D_FILE_OFFSET_BITS=64
    -D_LARGEFILE_SOURCE

  LFS kikapcsolva:
    -DX_LFS_
    -DX_FILE_OFFSET_BITS=64
    -DX_LARGEFILE_SOURCE
    
  Az _LFS_ szimbólumot használja a CCC könyvtár az #ifdef-ekhez.
  Az _FILE_OFFSET_BITS és _LARGEFILE_SOURCE a gcc beépített makrói.
  Az eléírt X betû hatástalanítja a definíciókat.
    
 
2002.11.20 -- 1.6.00
  Portolás gcc3-ra:
  a megjelenítõkönyvtárak dinamikus betöltése átdolgozva;
  not() helyett mindenhol topnot() (a kódgenerálásban is);
  a korábbi gcc296.compat kihagyva;

2002.09.10 -- 1.5.08
  Egyenlõség (és egyenlõtlenség) vizsgálat kiterjesztve
  az ARRAY, OBJECT, BLOCK típusokra. Egyenlõek, ha ugyanaz
  az oref-jük.
  
  Korábban BLOCK-ok egyenlõségét egyáltalán nem lehetett vizsgálni,
  ARRAY-re és OBJECT-re == értelmezve volt, de != nem (vajon miért?).

2002.08.28 -- 1.5.07
  brwCreate(t,l,b,r) argumentumok nélkül is hívható, 
  ebben az esetben maximálisra inicializálja magát.
  
  brwArray olyan gotopblock/gobottomblockot tesz a browseba,
  ami .f.-fel jelzi, ha a pozícionálás sikertelen, korábban
  gotopblock/gobottomblock  visszatérési értéke NIL volt.

2002.06.28 -- 1.5.06
  variable.cpp korszerûsítve: egyedi oref_size adható meg.

2002.06.26 -- 1.5.05
  Hibás volt a statikus változók inicializálása clpstvar.cpp-ben:

  stvar::stvar( void (*inicode)() )
  {
      vartab_ini();  //Inicializálja a változóteret, 
      inicode();     //végrehajtja inicode-ot, eredmény a local stacken, 
      ptr=ststack;   //beírja az stvar objektumba a static stack mutatóját, 
      STPUSH(POP()); //átteszi a VALUE-t a local stackrõl a static stackre. 
  }

  Itt ptr-nek az inicode által készített értékre kell mutatni.
  A korábbi "ptr=ststack;", "inicode();" sorrend hibát eredényez, 
  ha inicode megváltoztatja a static stack pointerét (ststack-et).


2002.05.31 -- 1.5.04
  FO_NOLOCK fopen mód bevezetve UNIX-on (nincs protokoll lock),
  set dosconv OFF  után FO_NOLOCK móban nyílnak a filék,
  set dosconv FILESHARE  bekapcsolja a protokoll lock használatát,
  egyúttal minden más DOSCONV flaget kikapcsol.

  Az fopen(...,FO_EXCLUSIVE+FO_READ) UNIX-on problémát okoz,
  ui. readonly access módban nyitott filére nem lehet felrakni
  az exkluzivitást biztosító write lockot. 
  Ezért az FO_READ access módot FO_READWRITE-ra cseréljük.
  Ez azonban readonly filérendszeren okoz bajt, ahol nem lehet 
  write módban megnyitni a filét, ezért readonly filérendszeren 
  fopen(...,FO_NOLOCK+FO_READ) módra váltunk.

  Az utóbbi váltás kifejezetten csak errno==EROFS esetén 
  történik meg, tehát pl. r--r--r-- hozzáférésû filéknél nem.
  Azt feltételezzük, hogy  readonly filérendszer esetén
  az exkluzivitás felesleges, ui. a filé úgysem módosulhat.
  (NFS particiót az egyik gép ro, a másik rw módban mountol?)

2002.05.28 -- 1.5.03
  o:(object)initialize return értéke tévesen NIL volt.

2002.05.22 -- 1.5.02
  object:(class)method, object:(parent@class)method,
  object:(super@class)method alakok támogatása.

2002.04.25 -- 1.5.01
  flgui memoedit pozícionálása javítva.
  Az flgui kurzornak legalább 2 pixel vastagnak kell lennie.
  A villogást 0.5 sec-rõl 0.3 sec-re gyorsítottam (külön kéne 
  szabályozni a ki/bekapcsolás idejét).
 
2002.03.28 -- 1.5.00
  Large File Support. 
  
  2.4.x-es kernelen az egész CCC rendszer a

      -D_FILE_OFFSET_BITS=64
      -D_LARGEFILE_SOURCE

  opciókkal fordítható. Az LFS 2.2.x+ReiserFS-en nem mûködik, 
  ezért ilyen rendszereken a fenti opciókat ki kell kapcsolni.
  Ha nincs LFS, de mégis LFS opciókkal fordítunk, akkor az fopen 
  nem tudja felrakni a filékre a filémegosztásnak megfelelõ lockot
  (ami 1024 GB-hoz került), és ezért pl. a memoread mindig ""-t ad, 
  így a build sem mûködik. A ténylegesen nagy filék kezelése csak 
  ext2-n volt tesztelve (késõbb teszteltem ext3-on is).
  
  A btbtx adatbázisformátum nagy (>2G) filékre is mûködik ext2-n,
  és kezeli (automatikusan fordítja) az eltérõ byte-sorrendet.
  
  Solaris port. Új bináris formátum: CCCBIN=sol (32 bit GCC). 
  Ezentúl meg kell adni az OS nevét is: CCCUNAME=linux/solaris. 
  CCCUNAME azonosítja az adott gépen végrehajtható binárisok fajtáját, 
  amik azonban keletkezhetnek egymással nem keverhetõ objectekbõl.

2002.03.16 -- 1.4.19
  Javítások a Windows GUI megjelenítésben:

  A brw:windows attribútumban tárolt HWND kiolvasása elõtt (C szinten)
  mindig ellenõrizni kell az attribútum típusát (új VALUE2HWND makró). 
  Amikor egy browse-nak még nincs ablaka, akkor brw:windows==NIL, és 
  ebbõl egy illegális double kiolvasása floating point errort okozhat.
  
  brwHide megszünteti a browse window-ját, korábban csak letakarta,
  ezért elõfordult, hogy megszûnt browse-ok letakart ablakai örökre
  megmaradtak, ráadásul rajta maradván a windowstacken zavart okoztak a 
  a legfelsõ browse keresésében, pl. a topbrowse() függvénynél.
  
  Javítás alert-ben minden platformon:

  interactive_alert()-nek minden platformon törölnie kell a keyboard buffert,
  máskülönben az alert azonnal értelmezi az esetleges keyboard-ban levõ
  leütéseket (Clipper kompatibilitás), 
  

2002.03.06 -- 1.4.18
  Flgui ablakok pozícionálásának javítása, hogy érvényre jusson a 
  KDE-ben beállított window placement policy.
  
  Az fltk dokumentáció szerint az önálló ablakokat Fl_Window(w,h,name),
  a childokat Fl_Window(x,y,w,h,name) konstruktorral kell csinálni. 
  Ehhez képest az flgui minden ablakot Fl_Window(0,0,0,0,name) hívással 
  csinált, és ezért minden ablak a bal felsõ sarokban keletkezett. 
  Az Fl_Window(w,h,name) alak univerzális használata szintén nem jó,
  mert azzal elszállnak a get-cellák.
  
  CCCWin(name) mellé csináltam egy CCCWin(x,y,name) konstruktort
  CCCWin(name) : Fl_Window(0,0,name) (korábban Fl_Window(0,0,0,0,name) volt)
  CCCWin(0,0,name) : Fl_Window(0,0,0,0,name) (ez helyettesíti az eredetit)

  CCCPanel(name) mellé csináltam egy CCCPanel(x,y,name) konstruktort
  CCCPanel(name) : CCCWin(name) : Fl_Window(0,0,name)
  CCCPanel(0,0,name) : CCCWin(0,0,name) : Fl_Window(0,0,0,0,name)
 
  Most minden ablak CCCWin(name) hívással keletkezik, kivéve a getek, amik a

  BrwCellPanel():CCCPanel(0,0,name):CCCWin(0,0,name):Fl_Window(0,0,0,0,name)
  
  konstruktorláncon keresztül jönnek létre. Azaz minden ablak konstruktora 
  változott (x, y határozatlan lett), kivéve a get-cellákat, amik ezután is 
  a régi módon pozícionálódnak.
  

2002.02.27 -- 1.4.17
  strtran javítás
  A korábbi változat nCount==NIL esetén max 1024 elõfordulást cserélt,
  és a kihagyott elõfordulások esetén (<nStart) nem jól lépett elõre.
  Az új változat sat-tal keres, ami gyorsabb, mint at(.,substr(...)).
  A javított változat ellenõrzötten Clipper 5.2e kompatibilis.

  UNIX main tisztogatás
  Még a main elõtt bennmaradt a stacken egy local változó (pop).
  Máshová került, kikommentezett részek végleges törlése.
 
2002.02.27 -- 1.4.16
  Az flgui megjelenítõ könyvtár portolása Windowsra.

  Kell hozzá az Fltk könyvtár windowsos változata, ami nincs a CCC
  directory struktúra alatt, hanem külön kell fordítani (Build projekt),
  és be kell másolni a C fordító include és lib directoryja alá.
  Ez csak MSC-re és Borlandra van meg, a Watcom fordító nincs támogatva.

  Az flgui forrásban az alábbi (csekély) módosítások történtek:

  A platformfüggõ modulok az flgui/unix és flgui/doswin könyvtár alá
  kerültek (nem sok ilyen van, lényegében csak a main-ek).

  Az alert és refreshscrn végtelen várakozó ciklusokat tartalmaztak
  (azaz lefagytak), ezeket megszüntettem, a tapasztalat szerint Linuxon 
  sem kellenek.
  
  Néhány többszörös inicializálást (a Borlandnál hibás) megszüntettem.
  
  A Linux-specifikusan megírt idõméréseknél #ifdef-fel beírtam a
  Windowson mûködõ változatot is. A windowsos változat Linuxon is mûködne, 
  mivel a GetTickCount függényen alapszik, ami a ccc könyvtárban is megvan.
  
  Linkelés:
  
  Jelenleg nincs elõre elkészített script az flguis linkelésre.
  Ehelyett a bapp_w320 scripttel kell fordítani, és explicite megadni
  a ccclw32f és fltk könyvtárakat a -b kapcsolóban.
 

2001.12.29 -- 1.4.15
  psignal.cpp modul, SET POSIX SIGNAL BLOCK/ENABLE makró

2001.12.06 -- 1.4.14
  SET DOSCONV ON/OFF makrók (#xcommand) bevezetése.
  rand() javítva (rövid volt a periódusa).

2001.11.22 -- 1.4.13
  GCC 2.96 támogatás. 

  A not() függvényt meg kellett szüntetni, mert az új C++-ban
  fenntartott szó lett, az új név: topnot(). A régi programok
  számára a gcc296.compat (object filé!) be van linkelve
  libccc.so-ba, ez tartalmazza az eredeti not() függvényt.
  
  Egy csomó helyen cast-ot kellett alkalmazni.
  E csomó helyen warning jött, hogy nincs \n a filé végén.

2001.11.11 -- 1.4.12
  A karakteres browse rossz sorba rajzolta a sávkurzort,
  ha a browse:headsep üres volt. A headskip-et ugyanúgy
  kell kiszámítani, mint a többi helyen.

2001.10.22 -- 1.4.11
  Linuxos karakteres megjelenítés hibái javítva:
  dummy módú programok (háttérben futva) ne lépjenek ki term_quit-tel;
  X konzolos programokban ne jelenjen meg feleslegesen üres ablak;
  cursoronoff defaultja on-ról off-ra változott;
  X konzolos program csak akkor kap message-et, ha van ablaka;

2001.10.05 -- 1.4.10
  UNIX _clp___quit()-ben az utolsó képernyõ frissítve (refreshscrn).
  Flgui-s alert caption-jében a szöveg ismétlése helyett programnév.

2001.09.20  -- 1.4.09
  UNIX clpfilio.cpp-ben fopen() javítva. 
  Az fopen(fname,FO_READ+FO_EXCLUSIVE) csak shared módot
  eredményezett, mert a UNIX (POSIX) az exkluzivitást jelentõ
  writelockot az FO_READ opció miatt readlockra cserélte.
  Ilyen esetben ezért az FO_READ módot belsõleg le kell cserélni
  FO_READWRITE-ra, aminek sajnos az is a következménye, hogy csak
  olyan filé nyitható meg exkluzívan, amire rw jogunk van.
  Hasonló (fordított) a helyzet az FO_WRITE+FO_SHARED móddal.

2001.09.04  -- 1.4.08
  Signalblock bevezetve NT-n is, WIN32-es main-ek felújítva,
  16-bites platformok és DOS4G támogatása végleg kivéve.

2001.08.19
  Új DEFINE_METHOD makró cccapi.h-ban. Ez egyszerûsíti az
  objektumokhoz való hozzáférést C++ szintrõl. Kód nem változott.

2001.08.05 -- 1.4.07
  Új függvény:  classIdByName()

2001.08.04 -- 1.4.06
  errorblock és signalblock teljesen szétválasztva.

2001.07.29 -- 1.4.05
  win32 gui-s alert és achoice szétválasztva
  a korábbi alert neve interactive_alert (chr, gui, flgui)
  alert, alertblock a forrásfa gyökerébe került
  alert, alertblock symgen.txt-bõl kivéve, interactive_alert berakva
  clperr.prg-ben: quitblock, ctrlcblock, signalblock (új), errorblock
  a default errorhandler nem csinál alertet, ha subsystem=="SIGNAL"
  (unix) signals.cpp nem errorblock-ot, hanem signalblock-ot értékeli ki
 

2001.07.20 -- 1.4.04
  Flgui inkey-ben kis javítás.

2001.07.19 -- 1.4.03
  Linuxos fclose-ban errno beállítva.

2001.07.17 -- 1.4.02
  Flgui achoice pozícionálása pontosabb.
 
2001.07.07 -- 1.4.01
  Új attribútum a browse-ban: flushright (default=.t.), ha ennek 
  értéke .f., akkor a számmezõket nem igazítja jobbra.

  Az NG szerint invalidate után a browse headingeket újra kell
  rajzolni, az flgui-s browse ezt nem tette meg.


2001.07.06 -- 1.4.00
  Forráskód egységesítés.


2001.06.24 -- 1.3.14.vm16
  A UNIX-os filetime.cpp modul áthozva a savex programból.

  getfiletime(fspec) --> {create_time, access_time, modif_time}

  Ha a filé nem nyitható meg, akkor {NIL,NIL,NIL}-t ad.
  Clipper szinten ezek szám/string (rendszerfüggõ) típusúak, 
  ezért más eszközök nélkül csak mentés visszaállításra alkalmasak.

  setfiletime(fspec,create_time,access_time,modif_time) --> success

  A getfiletime-ból kapott idõket felteszi a filére. 
  Ha valamelyik idõ NIL, akkor azt nem módosítja.
  Ez biztosítja, hogy getfiletime hibája esetén setfiletime
  egyszerûen hatástalan, nem pedig elrontja a filé idõket.

  E két függvény a datidx adatbáziskezelõben a filé idõ mentésére,
  visszaállítására van használva, de korábban csak Win32-n mûködött
  (UNIX-on ki volt #ifdef-elve). Mivel UNIX-on is szükséges a filéidõk
  ugyanolyan mentése, a modult be kell tenni az alapkönyvtárba.


2001.06.17 -- 1.3.14.vm15
  Az object típusok listázása attrvals-ként qqout-ban.
 
2001.06.06 -- 1.3.14.vm14
  xmethod.cpp bõvítve az iniobjectfromarray() függvénnyel.

2001.04.26 -- 1.3.14.vm13
  Karakteres browse sávkurzorjának a pozícionálása rossz volt,
  ha egy oszlopnak sem volt headingje.

2001.04.09 -- 1.3.14.vm12
  Javítás NT-n a karakteres billentyûzet olvasásban.

2001.03.25 -- 1.3.14.vm11
  A _method_ osztály a neveket a statikusan foglalt char slotname[24] 
  bufferban tárolta, most csak a név pointerét tárolja, így a név
  akármiyen hosszú lehet.

2001.03.06 -- 1.3.14.vm10
  A displaysunkenget függvény átnevezve _get_displaysunkenget-re
  (általában a belsõ használatú függvényeket jobban el kell dugni). 

2001.03.01 -- 1.3.14.vm9
  mask.prg-ben getlistet a display metódussal kell megjeleníteni,
  máskülönben a get leszármazottaiban nehéz felüldefiniálni display-t.

  Flgui-s checkbox és radiobutton mutatják a fókuszt. Korábban csak
  egy ideiglenes implementáció volt készen. A listboxok pozícionálása 
  továbbra is rossz.

2001.02.24 -- 1.3.14.vm8 
  Dirsep függõség javítva doswin-es truename-ban és clpcpfil-ben.

  A dosfname2unix helyett a convertfspec2nativeformat függvény használandó,
  ami UNIX-on változatlan formában tartalmazza dosfname2unix-ot, viszont
  szimmetrikusan NT-n is implementálva van. Kompatibilitási okokból UNIX-on
  egyelõre megmaradt a függvény a régi néven is (de a CCC könyvtár
  belsõleg már nem használja).
  
  NT-n convertfspec2nativeformat csak a "/"-t konvertálja "\"-ra, 
  de erre sincs mindig szükség, ui. a C könyvtár sok esetben elfogadja
  a UNIX-os szintaktikát is, pl. rename(), remove().
  
  Típushiba (1) 

  Mivel a portolás iránya DOS->UNIX volt, a CCC általában jól kezeli 
  (UNIX-on is) a DOS-os szintaktikájú filénevekkel megírt programokat.
  A fejlesztési platform azonban átkerült UNIX-ra, így a programokban
  elõ fognak fordulni UNIX-os szintaktikájú filénevek, viszont ezeknek a
  kezelését meg kell oldani NT-n is!
  
  Típushiba (2)
  
  A convertfspec2nativeformat függvény hatása nem szabad, 
  hogy kilátszódjon a hívó függvénybõl, azaz nem szabad az argumentum
  értékét megváltoztatni. Ennek néhány UNIX-os függvény jelenleg nem
  felel meg.

2001.02.20 -- 1.3.14.vm7
  További belsõ használatú függvények prefixelve: _brwaux_.
  A karakteres bowse-ban implementálva hilite, dehilite.
  
  Rossz volt a veremkezelés classid.cpp-ben. A verem teteje 
  fölé nyúlt, ahol a mostani javítások elõtt mindig az a változó 
  volt, mint ami éppen kellett, ezért nem vettük észre.

2001.02.13 -- 1.3.14.vm6
 
  A get osztály metódus függvényeinek prefixe: _get_,
  a tbrowse osztály metódus függvényeinek prefixe: _tbrowse_.
  Ezt a konvenciót volna célszerû kövteni minden esetben,
  amikor a metódusok implementációja nem static.
  A cccui táblák újra lettek generálva a ccctools-ban lévõ 
  symgen programmal.

  Minden osztályban betartva az alábbi névkonvenció:
  
         osztályClass, osztályNew, osztályIni
         
  Ez a névkonvenció illeszkedik a régi Clipperben használt
  függvénynevekhez: errorNew, tbcolumnNew, tbrowseNew, getNew.
 

2001.02.08 -- 1.3.14.vm5
  Karakteres DispBox() kezeli a hatodik (szín) paraméterét.
  
  Karakteres browse kompatibilitás
  --------------------------------

  A browse néhány belsõ használatú attribútuma a kiterjesztett
  browse cargo-jában volt tárolva, emiatt egyszerû (menü nélküli) 
  browse nem volt önállóan létrehozható. Most ezek az attribútumok 
  átkerültek a rendes helyükre (valódi attribútumok lettek). 
  Például :cargo[BR_SHIFT] helyére mindenhol :_shift_ került.
  
  A column osztály width attribútuma metódus lett belsõ mûködéssel.
  A korábbi, hasonló célú brwColumnWidth() függvény megszûnt.  
  További új metódusok a tbcolumn osztályban: datawidth, color.

  A karakteres browse most megfelelõen rajzolja ki magát akkor is, 
  amikor minden oszlop heading üres, vagy üres a headsep. Lehetséges 
  volna achoice-ot implementálni browse-zal.

  A vízszintes mozgások left(), right(), home(), end(), panleft(), 
  panright(), panhome(), panend() NG kompatibilisen implementálva 
  lettek, az _actcolpos_ attribútum megfelelõen karban van tartva.
  
  Az autolite attribútum Clipper kompatibilisen inicializálódik,
  és az aktuális cella a második browse színnel ki van emelve.
  Implementálva lett a cellák színezése, kivéve a colorrect-et.

  A számoszlopok jobbra igazításához szükséges korrekció bekerült 
  a karakteres browse stabilizálásába. A brwEditCell függvényben
  továbbra is szükség van a pozícionálás korrekciójára, ui. az
  oszlopnak nincs mindig egyértelmûen meghatározott típusa.
  Pl. a KDIRDD-beli rekordmódosításkor bármilyen típusú adatok
  lehetnek ugyanabban az oszlopban.
  
  A karakteres _scanlines() függvény helyére a windows-ból átvett
  _scanlines (készítette Szabó Richárd) került, mert az jobban tûri 
  a "while !b:stabilize; end" típusú stabilizálást. _scanlines nem 
  fogyaszthat billentyûleütéseket, mégis a fenti ciklusból ki kell 
  tudni jönnie akkor is, ha nextkey() leütést jelez, és emiatt a 
  stabilizálás több lépésben történik (azaz inkrementális).
  

  Mindezek a javítások csak a kompatibilitás és a szépség kedvéért
  történtek, ui. nincs rájuk szükség a gyakorlatban. A browse azonban 
  még így sem teljesen kompatibilis:

  0) A GUI-s browse (amellyel a jelenlegi javítások nem foglalkoztak) 
     a természetébõl adódóan inkompatibilis. A GUI-s esetben nincs 
     szándékos változás, a browse továbbra sem mûködhet ablak, azaz
     brwShow() nélkül.

  1) A megjelenítés nem használja az oszlopra egyedi column:headsep,
     column:footsep, column:colsep értékeket.
  
  2) A színezés nem veszi figyelembe a colorrect attribútum tartalmát.
  
  3) Az oszlopok szélességének automatikus maghatározásánál a régi
     Clipper nem veszi figyelembe az oszlop picture-jét, ami hiba. 
     A CCC beszámítja a picture-t is.

  4) Nem mûködik hilite, dehilite.
  

2001.01.31 -- 1.3.14.vm4
  message(NIL,NIL) elszállása kivédve a karakteres könyvtárban,
  ez valójában nem követelmény, de a GUI-s könyvtár is lekezeli,
  a javítást Cs.L. küldte.


2001.01.11 -- 1.3.14.vm3
  Upper/lower karakterkonverzió támogatása ékezetes betûkre.
  Egyelõre csak új konverziós tábla készült, az upper(), lower() 
  a régi módon mûködik. Az új konvrezió így használható:

  #define UPPER(s) _charconv(s,CHARTAB_LOWER2UPPER)
  #define LOWER(s) _charconv(s,CHARTAB_UPPER2LOWER) 
  

2000.12.25 -- 1.3.14.vm2
  flgui színkezelés tovább javítva
  flgui színek és fontok konfigurálása
  cccapi.h-ban új makró: _retnd (azonos _retni-vel)
  trigonometrikus függvények

2000.11.24 -- 1.3.14.vm1
  flgui színkezelés javítva
  gettick.cpp betéve a közös forrásba (benne UNIX-os GetTickCount)
  a message-ek lassítva vannak a hunyorgás csökkentése érdekében
 
2000.11.08 -- 1.3.14
  Forráskód egységesítés.

2000.09.30 -- 1.3.13.vm13
  A Cs.L. féle flgui-s brwEditCell kijavítva, most jól pozícionálja
  a számmezõket is. A megváltozott API brwEditCell-ben visszacsinálva.
  A hiányzó brwGetRow és brwGetCol üresen implementálva,  hogy legalább 
  a linkelést ne akadályozza.


2000.09.28 -- 1.3.13.vm12
  Pótolva az flgui könyvtárból hiányzó beep().
  DOS-os printernevek felismerése javítva UNIX-ban.

  A ccctools/lpr-hphun nyomtató filter egyszerû nyomtatást tesz 
  lehetõvé Linuxon. Ez mindent tud, amire a Kontónak szüksége van,
  feltéve, hogy HP Laserjet komaptibilis nyomtatónk van.


2000.09.21 -- 1.3.13.vm11
  Új modul a megjelenítõ könyvtár statikus linkelését lehetõvé 
  tévõ cccui_static.cpp. Ebbõl ugyanolyan (és ugyanúgy használandó) 
  lib készül, mint a korábbi flgui.lib, chr.lib, auto.lib. 
  Az új könyvtár neve static.lib. Most minden kombinációban alkalmazható 
  a statikus és dinamikus linkelés.


2000.09.20 -- 1.3.13.vm10
  createwindow felvétele  cccui-ba
 

2000.08.18 -- 1.3.13.vm9
  A (2000.07.01 -- 1.3.13.vm4) változtatás a billentyûzet 
  olvasásában elrontotta a CAPSLOCK konverziót, javítva.


2000.08.03 -- 1.3.13.vm8

  Kísérlet a BCC fordító korlátjának (max 50 megnyitható filé)
  megszüntetésére. Végül az alábbi megoldás született:

  1. A cw32mt.lib könyvtárból ki kell venni az alábbi modulokat:
     _lock.obj, files.obj, files2.obj
  2. A "wdisasm %1 -a" programmal assembly forrást állítunk elõ belõlük.
  3. A forrást a kommentek helyén a kívánt filészámnak megfelelõen módosítjuk.
  4. A módosított asm filéket a wasm programmal lefordítjuk.
  5. A módosított objecteket linkeljük a lib-beli változat helyett.

  Megjegyzés: wdisasm és wasm a Watcom 10.5-bõl származik  
 

2000.07.25 -- 1.3.13.vm7
  set VREF_SIZE=99999 beállítja a VREF tömb méretét
 

2000.07.24 -- 1.3.13.vm6
  error_gen()-ben string() helyett stringn()
  

2000.07.09 -- 1.3.13.vm5
  A karakteres és az flgui könyvtárban ki volt felejtve
  a listbox osztály scan metódusa.


2000.07.01 -- 1.3.13.vm4
 
  Bõvítések a Windows-os GUI kódban
  
  caret.cpp    : Clipperbõl hívható caret függvények
  winposi.cpp  : a caret pozícionálása változott
  scroll.cpp   : scroll() implementációja display ablakban (üres volt)
  savescrn.cpp : savescreen/restscreen implementációja displayben (üres volt)
  clpcons0.cpp : üresen implementált függvények különvéve

  clpconsw.cpp : a billentyûzet olvasása lényegesen változott
  
  wm_syskeydown_translated(0/1) szabályozza, hogy a Windows 
  dolgozza-e fel pl. az ALT-os menüvezérlõ billentyûket, vagy a 
  Clipper szokásos inkey kódjait adja.

  winodsp.cpp  : automatikus display, caret kezelés
   

2000.06.04 -- 1.3.13.vm3
  asize GPF-fel elszállt negatív méretre, pl. asize({},-1).
  A Clipper kompatibilis eredmény: {} (nem jelez hibát).


2000.05.30 -- 1.3.13.vm2
 
  A unixos run-ból kivettem a káros refreshScrn()-t,
  mert az olyan alkalmazásnak is display-t csinál,
  amelyiknek nincs rá szüksége.
  
  Warningok javítva:

  unix/signal.cpp
  flgui/cccalert.cpp
  flgui/cccbrw.cpp
  flgui/cccpanel.cpp
  flgui/cccwin.cpp
  flgui/initgui.cpp
  flgui/objgetc.cpp


2000.05.29 -- 1.3.13.vm1
 
  Számozás értelmezése
  --------------------
  
  fõverzió:  1
  alverzió:  3
  javítás : 13    (csak az egységesített javítások)
  Csiszár : cslX  (Csiszár L. által végzett, még nem egységesített)
  Vermes  : vmX   (Vermes M. által végzett, még nem egységesített) 
  
  Mivel a forráskod UNIX-on és Windows-on egységes, azért a javításokat
  nem a platform szerint osztályozzuk, hanem, hogy ki csinálta.

  A következõ egységesített verzió 1.4.00 lesz, miután
  1) az FLGUI-ba bevettük az új kontrolokat (msk2say),          OK
  2) az cccui_api táblát megfelelõen kibõvítettük,
  3) a warningokat kijavítottuk,                                OK
  4) és a mostani egységesítés változtatásai leülepedtek.


  Javítások
  ---------  

  Az új kontrolok egyszerû (kompatibilitást biztosító)
  implementációja. A check és radio box lényegében mûködik a 
  karakteres implementációval, a listboxra átvehetõ a WINGUI-s
  implementáció.
  
  Hibák: 
  
  1) A check és radio boxokban a háttérszín nem mutatja a fókuszt.
  2) A listboxoknál a getmenü nincs pontosan pozícionálva, és
     a feljövõ achoice-ban nem mûködnek a számoknál lévõ nyílbillentyûk
     (ez általános hiba).


2000.05.26 -- 1.3.13
  Forráskód egységesítés


2000.05.22 -- 1.3.12
  NT-n direxist a gyökér directorykat is felismeri.
  
  Hiba: semelyik C compiler sem jelez hibát, 
  ha a chdir("../../..") alakú hívás a gyökérnél is feljebb lépne,
  ezért a truename("../../..") sem jelzi a hibát várt módon
  (nem könnyû kijavítani, egyelõre marad a hibás változat).
  

2000.05.10 -- 1.3.11
  listbox támogatás
  egyelõre hibás: gui-ban ismeretlen eredetû (nem kijavított) GPF 
  keletkezett a listbox használata közben, sajnos nem reprodukálható


2000.04.26 -- 1.3.10
  alertblock() bevezetve, így alert() átdefiniálható
  errorblock() mintájára


2000.04.22 -- 1.3.09
  Checkbox és radiobutton támogatás.

  objgetw javítás:
  Hasfocus-t attribútumként kell implementálni
  setfocus .t.-re, killfocus .f.-re állítja.


2000.04.20 -- 1.3.08
  brwmenu.cpp (Win32 GUI) a menüszeparátor cseréje pótolva


2000.03.17 -- 1.3.07
 
  Javítások brwedit.prg-ben: 
  1. a korábbi változat nem jól ment át az .f. preblockú geteken
  2. most egységes a kód CCC console, CCC Windows-GUI és régi Clipper
     platformokon (#ifdef-ekkel)
     
  (Ez a hiba régrõl ismert volt, pl. emiatt szállt el dstru/xstru.)

2000.03.13 -- 1.3.06

  UNIX-os putenv-be strdup.

2000.03.04 -- 1.3.05
 
  fclose-ban a VALID_HANDLE makró finomítva

2000.02.20 -- 1.3.05
 
  UNIX-os warningok kitisztítása

  A C++ fordítási opciók közé betettem a -Wall flaget,
  és a további warningokat kitisztogattam.
  
  clparit.cpp             unsigned/signed összehasonlítás javítva
  chr/unix/clpcons.cpp    unsigned/signed összehasonlítás javítva 
  clpdkonv.cpp            format int <--> arg long
  unix/clpfilio.cpp       struktúra inicializálás
  clptrans.cpp            értékadás értéke
  unix/clpukieg.cpp       unsigned/signed összehasonlítás javítva  
  include/global.h        struktúra inicializálás 
  chr/objgetc.cpp         értékadás értéke 
  chr/unix/signals.cpp    struktúra inicializálás  
  unix/stat.cpp           visszatérési érték
  chr/unix/terminal/termapi.cpp  visszatérési érték 
  variable.cpp            unsigned/signed összehasonlítások javítva (!!!)

  A C++ fordítási opciók közül kivettem a -w flaget,
  és a warningokat kitisztogattam.

  unix/sleep.cpp          nem kell a double és a floor
  unix/include/vcbase.h   min, max redef javítva
  clpbreak.cpp            típus nélküli deklaráció javítva
  unix/clpfilio.cpp       string.h inkludálva 
  unix/clpsys.cpp         string.h inkludálva
  unix/clpukieg.cpp       típus nélküli deklaráció javítva 
  unix/diskfree.cpp       unistd.h inkludálva 
  variable.cpp            típus nélküli deklaráció javítva 
 

2000.02.18 -- 1.3.04
  direxist paramétere végzõdhet "\"-re is

2000.02.15 -- 1.3.03
  color.cpp helyett screenchr.cpp bõvített tartalommal.

2000.02.11 -- 1.3.02
  w32c_keyb.cpp: javítva a char->short konverzió hibája
  az ascii kód kiolvasásában

2000.01.15 -- 1.3.01
  Hibaüzenetek javítása clparr-ban.

2000.01.13 -- 1.3.00
  CCC kódrendszer bevezetése.

2000.01.08 -- 1.2.05

  NT-UNIX forráskód egységesítés.
  clpbit.cpp-ben setbit() javítva.


1999.12.29 -- 1.2.04.w17

  A DOS, 4G extender, Win16 támogatása teljesen megszûnt,
  az ezekhez a platformokhoz tartozó kód el lett távolítva.
  
  A remote-olással kapcsolatos programok modulárisabbak lettek.
  A conapi_... változók egy függvénypointer táblát alkotnak,
  amit a load_terminal() tölt fel a remote_... függvények
  címeivel (terminal.dll-bõl), vagy a local_... függvényekkel.
  
  A local_... függvények a w32c_...cpp modulokban vannak
  definiálva: w32c_keyb, w32c_video, w32c_wsid, w32c_remio.
  
  Példa: a korábbi maxrow() függvény helyett a conapi_maxrow()
  hívást kell végrehajtani, ami a load_terminal()-tól függõen
  a remote_maxrow()-t, vagy a local_maxrow()-t hívja meg.

      #define maxrow  conapi_maxrow

  típusú makrók biztosítják, hogy ne kelljen a programot 
  átirkálni. A változások nem érintik a GUI-s könyvtárat.
  
  
  új CA-tools függvények: ksetscroll, ksetnum, ksetcaps



1999.12.14 -- 1.2.04.w16

  Elavult UNIX-os források törölve.

  Devout()-ban a használaton kívüli UNIX-os #ifdef-ek törölve.
  
  A crlf() függvény endofline()-ra cserélve qout-ban memoline-ban és
  memoedit-ben.
 

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SIKERTELEN MóDOSíTáSI KíSÉRLET
  
  A konzolos változatban charconv(WIN2CWI) átkerült volna puttext-be.
  Sajnos ez módosítás jelenleg nem lehetséges, mert elromlanak a maszkok 
  dobozrajzoló betûi. Ez már korábban is ismert volt, csak elfelejtettem. 

  Megoldás lehetne, ha félreesõ helyeken új dobozrajzoló karaktereket 
  definiálnánk. Ekkor volna 4 diszjunkt karakter osztály:
  
     437   ékezetes betûk
     850   ékezetes betûk
     XBOX  egységes dobozrajzoló karakterek
     ASCII minden egyéb (sosem kell konvertálni)
     
  A halmazok diszjunkt voltát XBOX megfelelõ kijelölése biztosítja.
  Jelenleg négyféle CCC/Clipper program létezik:
  
     Clipper (régi)
     NT konzol
     NT GUI
     Linux 
  
  Az utóbbi három esetben a programok a 4 karakterosztály teszõleges 
  keverékébõl állhatnának:
     
     NT konzol :  437->OK,  850->437, XBOX->BOX437   
     NT GUI    :  437->850, 850->OK,  XBOX->blank    
     Linux     :  437->850, 850->OK,  XBOX->OK?       
     
  Vagyis ezekben az esetekben ugyanaz a program a megjelenítéskor
  egyértelmûen konvertálható a natív kódrendszerre. Sajnos azonban
  a régi Clipper-ben nincs (?) lehetõség a megjelenítés elõtti
  konverzióra, ezért a magukat a Clipper programokat kell konvertálni.
       
 

  (Linuxon a konverzió még csak nem is a puttext-ben, hanem lejjebb,
  a terminálban van. Ennek elõnye, hogy a puttext és gettext egymás 
  inverzei. Egy ilyen megoldáshoz NT/DOS-on 3 helyre kéne betenni 
  konverziót: a közvetlen megjelenítésbe, az NT-s terminálba, és a 
  DOS-os terminálba. A közvetlen megjelenítésnél azonban nincs közbülsõ 
  képernyõ buffer, ezért a gettext mindig a konvertált szöveget kapja meg.)
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


1999.09.11 -- 1.2.04.w15

  Portolás Inprise CBuilder 4-re (5.4-es compiler)
  
  Fordítás
  --------
  
  Az új compiler a windowsos handle típusokat szelektívebben vizsgálja, 
  ezért a void*, HANDLE, HWND, HBRUSH, HDC, HPEN, HMENU típusokat nem 
  lehet keverni, hanem castolni kell.

  Fordítási opcióként definiálni kell a _MT szimbólumot, máskülönben
  a cw32mt könyvtárral linkelve hiányozni fog az errno globális változó.
  Nyilván lyuk volt a korábbi multithreaded könyvtárban, 
  ui. több thread osztozott az egyetlen errno változón.
  
  A display window-k kiemelése BCB4-ben azonossá vált MSVC5-tel,
  így most a Watcom változat tér el a többitõl.
   

  Linkelés
  -------- 
  
  TLINK32 helyett ILINK32-vel kell linkelni (nincs TLINK). A linker 
  paraméterezését nem kell módosítani. Az exe mellé mindig lerak 
  egy tds kiterjesztésû (external debug symbol table) filét, 
  és több munkafilét, amiket le kell törölni.
  
  FONTOS, hogy nem szabad keverni a régi és új objecteket és libeket,
  annál is inkább, mivel a hiba nem látszik minden programban, és
  késõbb aztán  nem lesz világos, hogy mi okozza a bajt.
  
  A bcb3-mal készített obj és lib filékben  "Borland C++ 5.3",
  a bcb4-gyel készített obj és lib filékben "Borland C++ 5.4"
  felirat található, ezt ELLENORIZNI kell az összes filére.
 


  Módosult
  --------

  winposi.cpp, winohlp.cpp, winohdg.cpp, winoget.cpp, winofoo.cpp,
  winoedi.cpp, winodsp.cpp, winocln.cpp, winocho.cpp, winobut.cpp,
  winobrw.cpp, brwclp.cpp: handle típusok egyeztetve
  
  
  bcc32.cgf: -D_MT
  
  
  obj2exe.bat és lib2exe.bat:
  
      tlink32 @%RSPLNK%. >outlnk    
      goto iferror
       
      helyett

      ilink32 @%RSPLNK%. >outlnk    
      del %BUILD_EXE%\%EXENAM%.ilc 2>nul
      del %BUILD_EXE%\%EXENAM%.ild 2>nul
      del %BUILD_EXE%\%EXENAM%.ilf 2>nul
      del %BUILD_EXE%\%EXENAM%.ils 2>nul
      del %BUILD_EXE%\%EXENAM%.tds 2>nul
      goto iferror
 

1999.09.01 -- 1.2.04.w14
 
  objgetc.cpp és objgetw,cpp modulokban egy GPF javítása,
  ami akkor keletkezett, ha egy "" kezdõértékû, template stringet 
  nem tartalmazó picture-rel rendelkezõ getre került a fókusz.


1999.07.29 -- 1.2.04.w13
   
  Az empty() függvény értelmezése változott "O" típusú
  változókra: egy objektum empty, ha nincs egy adattagja sem.
  A korábban is létezõ osztályoknál ez nem okoz változást.
  Egy objektum így tehetõ emptyvé: asize(getobjectasarray(object),0).
  Az emptyvé tett objektum attribútumai nem léteznek, a rájuk való
  hivatkozás run time errort okoz.  A változtatás azért  szükséges,
  hogy a táblaobjektum generáló függvényekben statikusan tárolt
  objektum kívülrõl destruct-olható legyen. 

 
1999.07.06 -- 1.2.04.w12

  memóriafoglalás átdolgozása

  a new operátor helyett MEMALLOC(size) makró,
  a delete operátor helyett MEMFREE(ptr) makró,
  a makrók a clp2cpp.h-ban vannak definiálva
  
  
  érintett modulok

      variable.cpp
      clparr.cpp
      winocho.cpp 
      winocln.cpp 
      winodsp.cpp 
      winofoo.cpp 
      winoget.cpp 
      winohdg.cpp 
      winohlp.cpp 
      
  Az MSC és Watcom jól mûködött a new/delete operátorokkal is,
  azonban a Borland C olyan saját memóriagazdálkodást végez,
  ami a CCC-hez nem a legjobb. Egyszerû programok (pl. KFOKONYV)
  a Borland C-vel is prímán mûködtek, azonban a SAVEX, ami akár 
  100 ezer objektumot is létrehozhat, a Borland C-vel pillanatok alatt
  kifogy a memóriából (többszáz MB-ot igényel). Egy fokkal jobb
  a helyzet a Borland malloc/free függvényekkel, de Win32-n legjobb
  a nyers GlobalAlloc/GlobalFree rendszerfüggvényekkel dolgozni.
  
  Példa Borland C-s SAVEX-ra:
  
  GlobalAlloc/GlobalFree    4890 filé          4 MB
  malloc/free               4890 filé         36 MB
  new/delete                4890 filé         nem tud lefutni
  

  Az MSC és Watcom fordítókkal készült SAVEX a new/delete
  operátorokkal sem fogyaszt 4-5MB-nél többet.

  

1999.06.30 -- 1.2.04.w11 
 
  errno.cpp    : errorcode() (CA-tools)
  dirname.prg  : dirname() (CA-tools)
  ascpos.prg   : ascpos() (CA-tools) 
  clpbit.cpp   : isbit, setbit, numand, numor, numxor, numnot (CA-tools)
  fileseek.prg : fileseek, fileattr, filesize, filedate, filedelete (CA-tools)
  month.prg    : addmonth, lastdayom (CA-tools)
  doy.prg      : doy, eom, eoy, bom, boy (CA-tools)
  clprand.prg  : rand(), random() teljesen kompatibilis
  freadstr.prg : freadstr() (Clipper standard, kompatibilis)
  expand.prg   : expand(), charspred() (CA-tools)
  filetime.cpp : win32 függvények filéidõk kezeléséhez
  systime.cpp  : win32 függvények filéidõk kezeléséhez
  setfdati.prg : setfdati() (CA-tools)
  like.prg     : like() (CA-tools, Csiszár L.)
  time2sec.prg : timetosec(), sectotime() (CA-tools)

  clpfpar.prg  : megszûnt, helyette fileseek.prg 
  clpcpfil.prg : egyszerûsítve, deletefile() (CA-tools)
  cccapi.h     : javítva(!), bõvítve
  winodsp.cpp  : display ablakok kiemelése MSVC-ben kihagyva


1999.06.25 -- 1.2.04.w10

  directory() Win32-API implementációja
  findfirst/findnext betéve az alapkönyvtárba


1999.06.17 -- 1.2.04.w9
  diskfree() implementálva Win32-ben
  ntdevice.cpp felülvizsgálva, áthelyezve doswin\win32-be
  ntutil.prg megszûnt


1999.06.12 -- 1.2.04.w8
 
  portolás Borland C-re (CBuilder 3)
  
  mkdir,sopen,open compilerfüggõ alakjai #ifdefelve,
  néhány signed/unsigned összehasonlítás javítva (még maradt),
  felesleges #include <iostream>-ek kivéve,
  variable.cpp-ben heapcheck csak WATCOM-ban nem üres,
  wherex/wherey Borlandban létezik, el kell kerülni,
  cccapi.h-ban a NULL pointereket castolni kell
  

  Módosult források:
  
  chr\doswin\main.cpp            Borland open
  clplock.cpp                    Borland locking
  clppad.cpp                     signed/unsigned
  clpstuff,cpp                   signed/unsigned 
  doswin\clpdir.cpp              Borland findfirst,findnext
  doswin\clpfile.cpp             Borland mkdir,chdrive,getdrive 
  doswin\clpfilio.cpp            Borland sopen konstansok
  gui\brwclp.cpp                 iostream kivéve
  gui\brwfunc.cpp                iostream kivéve 
  gui\brwmenu.cpp                iostream kivéve 
  gui\clpdoutw.cpp               iostream kivéve 
  gui\win32\mainw32.cpp          Borland open
  gui\winobrw.cpp                iostream kivéve 
  gui\winocho.cpp                iostream kivéve 
  gui\winocln.cpp                iostream kivéve 
  gui\winofoo.cpp                iostream kivéve 
  gui\winohdg.cpp                iostream kivéve 
  gui\winohlp.cpp                iostream kivéve 
  include\cccapi.h               NULL pointerek castolva
  include\video.h                wherex, wherey átnevezve
  variable.cpp                   heapcheck csak WATCOM-ban
 



1999.05.31 -- 1.2.04.w7
  exename() javítása


1999.05.29 -- 1.2.04.w6 
 
  putenv() javítás
  
  A C könyvtári putenv() NEM készít másolatot a kapott stringbõl,
  ezért nem hívható olyan nem fix string paraméterrel, amit a CCC 
  szemétgyûjtése eltakarít. Két megoldás van: 

  1) durván strdup()-pal másolatot csinálni, és beletörõdni, 
     hogy felesleges string bufferek maradnak, vagy

  2) használni setenv()-et, ami másolatot csinál a stringbõl.
  
  Egyszerûbb és biztosabb az strdup()-os változat. A UNIX-os
  kódban is kell javítani.


  signed/unsigned warning javítása clpdoutw-ben
  
  minden filénév kisbetûre konvertálva
  


1999.05.20 -- 1.2.04.w5
  #ifdef-ek és szimbólumok tisztogatása
  clpqout Borland _InitEasyWin() kihagyva
  winbrw.cpp-ben #ifdef __WINDOWS__ helyett #ifdef _16_
  
  Inkompatibilitás:
  keyboard( chr(255) ); inkey()
  Watcom-mal és Clipperben 255-öt ad, MSC-vel -1-et.
  GUI-ban és karakteres módban is a keyboard bufferbe
  másolt karaktereket 255-tel maszkolni kell.

  Megjegyzés: a Clipper dokumentáció szerint csak 0-255
  inkey kódok vihetõk be a keyboard utasítással, ezért
  a maszkolás biztosan jó.


1999.05.11 -- 1.2.04.w4
  Clipperben az ascan() függvény default keresési módja az '=' 
  operátorral történõ összehasonlítás. Korábban CCC-ben az '==' 
  operátort használtuk. Az inkompatibilitás javítva: !(...!=...).

 
============================================================================
CD (2) 1999. március CCCLIB
============================================================================
 
1999.03.21 -- 1.2.04.w3
  A Watcom C-s _grow_handles a ctccc.cpp modulból át lett hozva az 
  alapkönyvtárba, minden platform main-je meghívja: _grow_handles(255)
  karakteres memoedit kezdõpozícionálása javítva
  
  A tesztek szerint MSVC5.0 már nem tartalmazza a régi 20-as korlátot
  a megnyitható filék számára.


1999.03.15 -- 1.2.04.w2
  MSVC-s könyvtárak neve és verziószámozása

1999.03.13 -- 1.2.04.w1
 
  Az alapkönyvtár fordítása MSVC5.0-val
  
  Az összes RegisterClass hívásban meg kell adni a hIcon paramétert,
  ezt a Watcom C++ megfelelõ default-tal pótolta.
  
  fsetlock/funlock hiányzó MSVC implementáció pótolva
  
  clpfileio: sopen konstansok WATCOM->MSVC leképezése javítva
  
  ntdevice: WNetGetUniversalName kihagyva
  
  A fõprogramokban az esetleges invalid file handlerek elfogyasztására
  használt open-t MSVC-ben _open-nel kell helyettesíteni.

  Az MSVC programokat kétféle opcióval lehet linkelni

  1. /subsystem:console
  
  Ezeknek van default konzolja, de nem tudnak ablakot csinálni,
  mert kötelezõen main()-nel kezdõdnek, ezért nem ismert a hInstance,
  amit a WinMain-bõl lehetne kapni.
     
     
  2. /subsystem:windows
  
  Ezek kötelezõen WinMain-nel kezdõdnek, és induláskor már nincs konzoljuk.
  (A Watcom C++ programok system=nt esetén megtartják az örökölt konzolt,
  system=nt_win esetén pedig leválasztják.) A set ALLOCCONSOLE=on opció
  hatására a GUI-s program új konzol nyit magának. A Watcom C++-ban
  automatikusan ebbe a konzolba irányítódik stdout/stderr, MSVC-ben
  azonban ezt az átirányítást külön meg kell csinálni freopen-nel.
  

  A Szabó R.-tõl örökölt források TAB-jai elrontották az indentálást,
  ezt esztétikai okokból javítottam.
  
 

1999.03.10 -- 1.2.04
 
  visszakerült a swap() függvény

  NT/Linux forráskód egységesítés, direktori struktúra az 
  alábbiak szerint:

TARTALOM

----------------------------------------------------------------------
/.
  közös források

/INCLUDE
  közös include filék  

/UNIX
  UNIX/LINUX specifikus források  
  
/DOSWIN
  DOS és Windows(16/32) specifikus források
  
----------------------------------------------------------------------
/GUI
  GUI-s megjelenítés Windows(16/32) forrásai (UNIX egyelõre nincs)
  
----------------------------------------------------------------------
/CHR
  karakteres megjelenítés DOS/Win/UNIX (közös)
  
/CHR/DOSWIN                            
  karakteres megjelenítés DOS/Window specifikus  

/CHR/UNIX                            
  karakteres megjelenítés UNIX specifikus  

----------------------------------------------------------------------


1999.03.04 -- 1.2.02
    kis javítás a win32c scroll() függvényben
    DispBox javítva (a frame paraméter különféle defaultjai)
    memoedit() javítva+optimalizálva, 1MB filékhez is alkalmas 
    sat.cpp új modul, sat() a standard at()-hez hasonló


============================================================================
CD (1) 1999. február
============================================================================
 
1999.02.04
    rfwrite, remote_fwrite
    raw outputot jelzõ flagek qout-ban
    computername lekérdezése a termináltól

1999.01.30 
    az új wmkgen-nel egyszerûsödött a make

1999.01.24 -- 1.2.01
    computername/workstatid

1999.01.19 -- 1.2.00
    többszörös öröklõdés, osztálystruktúra újraírva


1999.01.17 -- 1.1.01

    Megszûntek a CLASS_osztálynév szimbólumok (mert nem fix
    értékek), helyettük az getclass_id(),... függvények adják
    CPP szinten az osztályazonosítókat.

    az oref táblázat ezentúl nem látszik ki variable.cpp-bõl,
    OREFIDX(), OREFPTR() (és ezzel az oref-re való külsõ hivatkozás) 
    megszûnt, index helyett a programok OREF* pointerrel tartják 
    nyilván az objektumot (pl. egy browse window a hozzá tartozó CCC
    browse objektumot), ezzel lehetõvé válik az oref tábla dinamikus
    bõvítése.

    64K feletti stringek támogatása, a stringek hossza egy 
    unsigned int típusú változóban van, a megengedett maximális
    string hossz MAXSTRLEN, ami platformfüggõen van definiálva,
    az olyan modulokat kell vizsgálni, amiben string.len található
    és különösen azokat, amik a string hosszát növelhetik,

    memoread,padr,padl,padc,replicate,space,stuff
    
    __maxstrlen() MAXSTRLEN értékét adja Clipper szinten

    
1999.01.15 -- 1.1.00
    exetended class system bevezetése
    2.3.01-nél magasabb verziószámú ppo2cpp kell hozzá
    bõvítésre és öröklésre képes osztálystruktúra,
    mindent újra kell fordítani

----------------------------------------------------------------------------
EXTENDED CLASS SYSTEM (egyelõre egyszeres öröklõdésû)
----------------------------------------------------------------------------

1999.01.07 -- 1.0.08
    képernyõ és billentyû szétválasztva: video32c<-->keyb32c

    remote_console() tölti be a terminal.dll-t,
    load_remote_terminal_dll egyetlen hívása itt van,
    korábban rfputs() a terminal betöltése nélkül elszállt
    

1998.12.27 -- 1.0.07
    új függvények az optimalizálóhoz

    flag_eqeqc, eqeqc
    flag_eqeqn, eqeqn
    assign_pop, assign_sym, assign_sym_pop


1998.12.18 -- 1.0.06
    A directory() findfirst, findnext ciklusa után hiányzott
    a findclose, és így a rendszer által foglalt statikus 
    adatok zárványként megmaradtak. Egyelõre csak az NT-s
    változatok vannak kijavítva, késõbb mindenhol javítani kell.


1998.12.08 -- 1.0.05
    SWAP makró megszûnt
    getenv()-ben a környezeti stringet stringn()-nel kell
    a veremre tenni, mert HP unixon nem fix a helye.
    
    karakteres achoice-ban WIN2CWI konverzió

    Karakteres browse puldownmenüjének javítgatása
    a szeparátor sort ("ÑÑ") mindig mértre vágja
    a szeparátoron entert ütve nem csinál semmit,
    ezért a szeparátornak nem is kell kódblokkot adni
    mint korábban, hanem ennyi is elég

                aadd(menu,{"Ñ"})  //chr(196)
    
    A pulldown menü blokkja által visszaadott érték értelmezése
    megváltozott

    1) nem szám      -> kilép a menübõl
    2) menüindex     -> odamegy
    3) 0             -> helyben marad
    4) egyéb szám    -> kilép
    
    Korábban csak az elsõ két eset volt kezelve,
    ezért a 3) és 4) esetben runtime error keletkezett.
    Az egésznek nincs nagy jelentõsége, mert GUI-ban
    ezek nem mûködnek, mert ott hagyom a Windows eredeti
    menükezelését érvényesülni.


1998.12.06 -- 1.0.04
    karakteres achoice-ban kezelve a 0 tételt tartalmazó eset
    errorlevel() tévesen NIL-t adott a beállított érték helyett
    memoedit() tévesen egy crlf-et rakott a szöveg elejére


1998.11.27 -- 1.0.03
    új make környezet, fordításkor a CCCLIB directoryt
    rootra kell mapelni!


1998.11.26 -- 1.0.02

    korábban így vettem elõ a konzol handlert:

    HANDLE hConOut=GetStdHandle(STD_OUTPUT_HANDLE);

    ez azonban nem mûködik, ha stdout át van irányítva,
    helyette CreateFile-t kell használni, a standard inputnál 
    maradt az eredeti kód

    conhnd=CreateFile(
       "CONOUT$",                        //address of name of the file
       GENERIC_READ|GENERIC_WRITE,       //access (read-write) mode
       FILE_SHARE_READ|FILE_SHARE_WRITE, //share mode
       NULL,                             //address of security descriptor
       OPEN_EXISTING,                    //how to create
       0,                                //file attributes
       NULL );                           //handle of file with attributes to copy


1998.11.10 -- 1.0.01
    Beep és Sleep paraméterellenõrzése javítva
    endofline, pathsep, dirsep függvények
    
    verziószámozás bevezetve, az összes platform ugyanazt
    a verziószámot kapja, a ver_ccclib() függvény meghívása
    nem automatikus, azt be kell írni a main-ba


1998.11.08
    brwColumn kiegészült egy pos paraméterrel,
    ha ez meg van adva, akkor nem addcolumn, 
    hanem inscolumn metódussal bõvül a browse

1998.10.02
    dow()-ban a napokat így kell sorszámozni:
        empty-date   0
        vasárnap     1
        hétfõ        2
        ...
        szombat      7
    korábban tévesen a hétfõ volt az 1-es, inkompatibilitás javítva.

1998.09.14
    javítások clp2cpp.h -ben:
    SWAP javítva
    OREFIDX makró megszûnt
    dbfield konstruktora nem inline (kikommentezve)

1998.09.08
    Az optimalizáló fordítóhoz új könyvtári függvények:
    addnum(val), mulnum(), addneg(val), idxr0(i), idxl0(i).

1998.07.23
    ctod() javítva, rugalmasabban alkalmazkodik az évszázadhoz

1998.07.23

    Javított cpp szintû fõprogramok: a system=nt_win alkalmazások
    stdout-jában lévõ 1 filé handler érvénytelen, ha ezt egy késõbb
    megnyíló filé megkapja, akkor az stdoutra szánt kimenet elrontja
    a filét (pl. ? a SZAMLA.DBF-be ír). Az új módszer ezt úgy kerüli
    el, hogy egy
    
                  while( open("NUL",O_RDWR)<3 );
    
    ciklussal elhasználja az alkalmazás elõl a szabad alacsony
    sorszámú filé handlereket. A módszer azon alapszik, hogy az
    open() növekvõ sorrendben adja a handlereket, ha azonban ez
    tejesül, akkor minden platformon alkalmazható óvintézkedés.
    A korábbi freopen-en alapuló módszer instabil volt, ez okozta
    pl. a 98.07.09-es programindítási hibát.


1998.07.22
    A karakteres browse brwShow-jában kell legyen configure,
    hogy a footing beállítások érvényre jussanak az alkalmazásban
    elhelyezett configure nélkül is (RedrawAll változott).
    
    A karakteres browse jobbra/balra panoláskor elvesztette
    a pozícióját, ezért a BR_SHIFT-ben tárolt esetleges elmaradást
    a brwScanlines-ban mindenképpen be kell hozni. Ha a stabilizáció
    nem panolástól, hanem le/föl mozgástól függesztõdik fel,
    akkor a shiftet hozzáadjuk a következõ mozgáshoz, ez korábban
    is jó volt.


1998.07.14
    clpdoutw-ben elõbb kell jönnie a BOX2BLANK konverziónak, 
    utána pedig a CWI2WIN konverziónak, egyébként a keretrajzoló
    karakterek és Windows ékezetes nagybetûk összekeverednek.

1998.07.10
    browse inkrementális stabilizálása a javítva
    GUI/CHR-ben egyaránt _setsl_incremental(), _setsl_minrowcount()
    új belsõ függvények (kivételesen az executiv is hasznlája)


1998.07.09

    új általánosabb karakterkonverziós függvények a charconv.cpp
    modulban, egyéb érintett modulok:
    
    karakteres modulok
    ------------------
    
    Korábban nem volt konverzió, ha azonban Windows-os programokkal
    visznek be ékezetes betüket, akkor azok nem látszanak a karakteres
    programban, ezért a megjelenítésnél vissza kell konvertálni CWI-re
    
    A UNIX-os változat a clpdout-ban mindent konvertál, ez nekem 
    túl sok, mert a box karaktereket a maszkokon is elrontja.
    Ezért csak speciális helyeken végzem el a visszakonvertálást,
    ahol tipikusan adatbázis tartalom jelenhet meg.
    
    problémák:
    
    Nyilván sok lyuk marad, pl. adatbázis tartalom alapján
    felépített menü, caption. Mi lesz az olyan nyomtatásokkal,
    amik box karaktereket tartalmaznak és egyúttal azonos kódú
    WIN ékezetes nagybetût.

    clpqout.cpp  : betéve charconv_top(CHARTAB_WIN2CWI)
    brwdisp.prg  : browse-ban megjelenõ adat konvertálva (win2cwi)
    memoedit.prg : memoeditben megjelenõ adat konvertálva (win2cwi)
    objget.cpp   : display-ben megjelenítés elõtt konverzió (win2cwi)
    

    GUI-s modulok
    -------------
    
    A CWI-s ékezetes karaktereket WIN ékezetesre konvertálom.
    A korábbi konverzió egyúttal a dobozrajzoló karakterek helyére
    blank-et rakott. Ez nem volt jó, mert pl. a WIN-É egybeesik egy
    CWI-box karakterrel, és ezért nem volt megjeleníthetõ.
    
    Most a box->blank konverzió csak a devout()-ban történik meg,
    ezzel a maszkokról leveszi a meg nem jeleníthetõ doboz jeleket,
    de a get-ekben browse-okban lehet Windows-os ékezetes karaktereket
    csinálni.

    brwclp.cpp   : inn2out cserélve charconv_string(CHARTAB_CWI2WIN,...)-re
    brwmenu.cpp  : _clp__inn2out cserélve charconv_top(CHARTAB_CWI2WIN)-re 
    clpdoutw.cpp : inn2out cserélve charconv_string(CHARTAB_CWI2WIN,...)-re
                   plusz charconv_string(CHARTAB_BOX2BLANK,...)-re
    objgetw.cpp  : inn2out cserélve charconv_string(CHARTAB_CWI2WIN,...)-re
    winapi.cpp   : _clp__inn2out cserélve charconv_top(CHARTAB_CWI2WIN)-re 
    winoedi.cpp  : _clp__inn2out cserélve charconv_top(CHARTAB_CWI2WIN)-re 


1998.07.09
    winmain32.cpp-ben set DebugArgs=on-ra a paraméterek listázása
    
    HIBA:
    Magyar Windows-NT Workstation-on a GetModuleFileName()
    lecsonkítva adja az exe nevét, és ezért az executiv nem
    tudja indítani a hosszú nevû programokat (feltevés)
       
    k:\konto.xxx\kx32dcg\knapforg.exe már nem indult el,
    k:\konto.xxx\kx32dcg\knapf0.exe (azonos) még jó volt
    
    a hiba determinisztikus, és a program indulásakor a
    Dr.Watson feljövetelével jelentkezik. A dolgok rendben vannak,
    ha nem magyar NT-t, hanem az itthoni NT szerveremet használom
    kliensnek.
    
    TÉVEDÉS: a problémát a 98.07.23-as javítás oldotta meg.


1998.07.08
    új modul clplock.cpp:
    vmm.cpp-bõl áthoztam és egységesítettem a lock függvényeket

1998.07.06
    javítás brwedit.prg brwGetCol()-ban:
    a karakteres browse editálásánál a számmezõk fölé tett get-et
    ugyanúgy jobbra kell igazítani, ahogy az a GUI-ban is volt

1998.05.28
    brw:freeze>0 esetén nem számolta ki a szélességeket

1998.05.22
    szignálok és GPF-ek kezelése
    
    1) CTRL-C kezelõ blokk az errorblock-hoz hasonlóan clperr-ben
    2) a SIGSEGV szignált elkapom és CCC-s runtime errort generálok

    clpstuff.cpp-ben rat() GPF-et okozott,
    a hiba determinisztikus volt, de nem minden gépen
    jelentkezett (csak workstation-on indítva lépett fel)
    compiler hibára utal, hogy a ciklusváltozó printelése
    megszüntette a hibát, az új kód mindenesetre tisztább

1998.05.17
    a karakteres browse rosszul mûködött olyan oszlopokkal,
    aminek a szélessége egymagában nagyobb volt, mint a browse

1998.05.03
    directory() nagybetûre konvertál (kompatibilitás!)
    varprint OREFIDX helyett az oref pointert írja hex alakban
    variable.cpp dinamikusan hozza létre oref,vref-et
    karakteres browse támogatja az oszlop színeket és footingot
    (az oszlop footingot és KONTO footingot nem lehet együtt használni)

1998.05.01
    dtos() az üres dátumra blanket kell adjon, nem pedig "00000000"-át
    global.h új modul a globális CCC tömbök definíciójára
    main.cpp átkerült a platformfüggõ aldirektorykba
    clperr.prg-ben új függvény: quitblock (errorblock-hoz hasonló)
    quit végrehajtja a quitblock kódblokkot


1998.04.16
    clpcons.cpp: új függvény getkey() (karakteresen is)
    clppad.cpp : 60K string támogatása (32K helyett)


1998.04.08
    áttérés pentiumra optimalizált fordításra
    nyilas mezõhivatkozások  fordítása (clp2cpp.exe)
    emiatt push_blkenv-ben új ellenõrzésre van szükség
    clp2cpp.h bõvült class dbfield-del


1998.03.29

    Az IO mûveletek visszatérésekor errno mindenhol 0:-1-re állítva,
    aszerint, hogy a mûvelet sikeres, vagy nem. Ez azoknál a függvényeknél
    is szükséges, ahol a C könyvtár nem állítja errno-t (clpfile,clpfilio).

1998.03.21

    MSVC curdir, diskname clpsys.cpp-be
    MSVC directory clpdir.cpp-be (WATCOM-os javítva)
    MSVC dirmake, diskchange clpfile.cpp 
    MSVC konstansok sopen-ben clpfilio.cpp

    variable.cpp Watcom-os heapcheck helyettesítve
    mainw32.cpp stdin,stdout,stderr-re freopen

    egy eltérõen kezelt signed/unsigned konverzió 
    miatt MSVC savescreen-ben a háttérszín rossz volt


    MSVC fordítás egyéb tapasztalatai

    clparit.cpp    include mem.h javítva
    clppad.cpp     include mem.h javítva, unsigned/signed warningok javítva
    clparr.cpp     unsigned/signed warningok javítva
    clpdkonv.cpp   unsigned/signed warningok javítva
    clpstr.cpp     include mem.h javítva, warningok javítva
    varprint.cpp   unsigned/signed warningok javítva
    clpcons.cpp    bios.h kihagyva
    objget.cpp     warningok: signed/unsigned, cast, deafult(!) javítva
    objgetw.cpp    warningok: signed/unsigned, cast, deafult(!) javítva
    clpdout.cpp    signed/unsigned javítva
    clpdoutw.cpp   signed/unsigned javítva
    winobrw.cpp    signed/unsigned, cast javítva
    video32c.cpp   remote_error void

    loadtrem.cpp   SHORT  __stdcall (*remote_... )(...) helyett
                   SHORT (__stdcall  *remote_... )(...) 

    video.h        mint loadterm.cpp
    
   

1998.03.20
    clp2cpp.h-ban a DUP makrók javítva
    forráskód egységesítés


1998.02.19
    Inkey kódokat adó getkey függvény, ez negatív kódokat is adhat,
    ezért getkey USHORT helyett short deklarációjú kell legyen,
    remote_getkey nem jelezhet hibát negatív értékkel
    
    setcursor(0) javítva
    

1998.02.08
    GetStockObject(SYSTEM_FIXED_FONT) helyett ccc_fixed_font()
    a buttonokban és a helpben ccc_prop_font()
    achoice elhelyezése duplán relatív a 1998.01.18-as javítás miatt
    WM_MENUSELECT-ben a helpszöveg megjelenítése
    Sleep(60) inkey-be és getkey-be

1998.01.18
    a browse és display objektumok a topwindow koordinátái szerint
    vannak elheyezve (GUI-ban), hogy egy arrébb húzott alkalmazás ablakai
    együtt maradjanak

1997.12.20
    ss ($ operátor) strstr-rel mûködött, nem jó 0-t tartalmazó stringre
    errno nullázva a filé müveletek elõtt
    winapi.cpp-ben: getmenu -->wndgetmenu, setmenu -->wndsetmenu


1997.12.04
    clppad.cpp: visszavettem a padl buherálós NIL kezelését
    clpbreak.cpp: quit-be Sleep(300)
    main.cpp: síma exit helyett _clp___quit-tel lép ki


1997.12.03
    karakteres __keyboard javítva
    karakteres brwLoop javítva (ONSTABLE)


1997.11.22
    setdatformat támogatás
    "@K D" picture hibásan mûködött
    "@K" picture dátumokkal GPF-et csinált
    új függvény dtoc-ra és ctod-ra (a dátumformátumok támogatására)


1997.09.21

    brwOnstable kezelés.
    
    A GUI-s browse-ban a WM_TIMER-ekkel való spórolás céljából
    csak akkor installálok timert, ha a brwOnstable() az elsõ
    brwShow() elõtt már be volt állítva, ehhez szükséges, 

    hogy a brwCreate, brwClear, dspCreate NIL-re inicializálja a 
    slotot (a korábbi {||.f.} helyett), emellett brwOnstable(brw,0) 
    (vagy bármilyen nem NIL empty) visszaállítja a blokkot NIL-re,
    
    onstable végrehajtása elõtt ezért vizsgálni kell a blokk típusát.
    
    A NIL-re inicializálást a karakteres browseban is bevezettem.


1997.09.18
    Javítások a karakteres browse-ban
    
    :rowcount véglegesen javítva az elõzõ megjegyzés szerint,
    a heading és footing kirajzolása _brwwidth()-bõl _Stabilize()-be
    került, _brwwidth() csak az :invalidate-tel elõírja újrarajzolásukat
    a következõ stabilizációban, alapelv, hogy minden tényleges képernyõ 
    outputnak a brw:stabilize()-bõl kell történnie!

    a brwFooting elõtt beállított speciális :footsep most érvényre jut


1997.09.17
    Javítások a karakteres browse-ban

    A :rowcount (sorok száma a browse-ban) len(:invalid)-ot adta,
    de :invalid nincs elég korán inicializálva, ezért az elsõ stabilizáció
    elõtti :gobottom (benne brw:rowpos:=brw:rowcount) elrontotta :rowpos-t,
    amitõl az stabilizáció elszállt.
    
    Jelenleg :rowcount a browse méreteibõl kiszámolja a sorokat,
    jobb volna helyette a :configure-val inicializálni :invalid-ot,
    de az jelenleg elrontja az oszlop headereket, ezért valószínûleg
    egy korai :stable vizsgálat is elrontja a browse-t.
    
    Meg kell javítani :configure()-t! 
    (nem :configure rossz, hanem _brwwidth(), 1997.09.18)


?1997.09.16
?    winbrw-ben implementáltam a brwOnstable() mûködtetéséhez                  
?    szükséges timert
?    
?    bizonyos szituációkban felgyûlnek a queue-ban 
?    a WM_TIMER message-ek, pl. brwEditRow() közben,
?    ennek hatása még nincs kitesztelve, annyi látszik csak, 
?    hogy nem 'gyorsan' romlik el a rendszer
    

1997.09.10
    chr() argumentumát nem D2INT-tel kell kerekíteni.

    új fopen és fcreat, ami sopen()-nel nyit és kreál, 
    feleslegessé téve az alábbi kísérletet

    korábbi kísérlet: 
      clpfilio.cpp-ben fopen és fcreat lock protocollal pótolja
      az exclusive open hiányát


1997.07.07
    Remote console _32c_-ben.


1997.06.18
    Forásskód egységesítés.
    asc-ban (unsigned char*) castot kell használni.
    get3d.ch átkerült srcwin-be.


1997.06.16

    alert() a legfelsõ ablakhoz igazodva helyezi el magát,
    ugyanígy message() is.

1997.05.31

    CLPSTUFF.CPP: bináris rész string keresésére 
                  at,rat-ben strstr,strcmp helyett memcmp


    CLPDIR.CPP  : új dos specifikus függvény: diskchange()
                  máshova került diskname()

1997.04.12
    vmm.cpp-ben xvgetbyte, xvputbyte
    defaultwindowcaption javítva (az elõzõ beállítást adja vissza)
    memoedit 1-gyel rövidebb stringet adott vissza, javítva


1997.03.02

    új függvények

    CLPQOUT.CPP : outerr,outstd (standard könyvtári)
    CLPDIR.CPP  : dirchange (CA-tools)
    CLPCGI.CPP  : cgigetinput CONTENT_LENGTH hosszúságú stringet 
                  olvas be stdin-rõl
    
1996.12.12
    Az NT hibája miatt ferase() és btrCreate() hatása nem 
    látszik azonnal directory()-ban és file()-ben, ezért az
    ferase(), :create, :open gyakran használt szekvencia nem
    jól mûködik. Az open még nem érzékeli a create által frissen
    létrehozott filét, és megkérdezi, hogy létrehozza-e.
    A hiba eddig csak NT kliensen fordult elõ, a szerveren (lokálisan)
    futó CCC programok eddig is jól mûködtek.
    
    Javításképpen file() és btrCreate() most ciklusban megvárja,
    amíg a változás megjelenik file()-ben.
    
    
    run közben (WINDOWS-ban) a várakozó alkamazás ablakai takarva
    vannak
    

1996.12.10
    BRWFUNC.CPP: a client window az itt található 
    wmsize, wmuser, wmbutton függvényekkel mozog a browseban. 
    Nagyon fontos, hogy akkor, amikor az ablak nem felül van, 
    vagy nincs engedélyezve, a browse semmiképp se mozogjon
    az adatbázisban, Ezért a fenti függvények (a biztonság 
    kedvéért) ellenõrzik, hogy szabad-e mozogni. Valójában a 
    browse-ban ellenõrzött és módosított WM_WINDOWPOSCHANGING 
    után nem szabad elõfordulnia mozgásnak.
    
    WINAPI.CCC: paintloop WM_PAINT dispatch-e után kilép, új 
    függvény Beep().
    
    Alert fütyül.
    
    WINMAIN.H: DEVOUT_WIDTH 128 helyett 192


1996.12.08
    Uj alert.
    
1996.12.07
    A client, heading, footing, get ablakok HOLLOW_BRUSH-t kapnak,
    ezzel egy csomó villódzás megszûnik. Másik lehetõség volna a
    WM_ERASEBKGND feldolgozása, vagy InvalidateRect-ben gondosan
    ügyelni a paraméterezésre. Sajnos 4.0-ban mindenképpen villodznak 
    az ablakok.


1996.12.05

    WS_MAXIMIZEBOX stílus kikommentezve a browseok kreálásánál,
    ui. a popwindowk becsukása, vagy ikonból elõhozatala megszûnteti
    a parent maximalizált állapotát (teljesen értehetetlen !!!),
    ez a parent browse adatbázisában pozícionáláshoz vezet, 
    ami pl. rekord módosításkor elrontja az adatbázist (VESZÉLY).
    
    További biztosíték a parent mozgatása ellen WM_WINDOWPOSCHANGING
    feldolgozása, ebben az alul lévõ ablak mozgatása elõtt a WINDOWPOS
    struktúrába mindig hozzáteszem a SWP_NOSIZE|SWP_NOMOVE flaget.
    Ezzel a maximalizált ablak ugyan nem változtatja a helyét és méretét,
    de a jobb felsõ sarok kettõs nyila visszaváltozik, azaz az ablak 
    maximális méretû, de normál állapotúvá válik (hülyeség).
    
    Client window (a tulajdonképpeni browse) brushja hollow, hogy
    a paintnél ne látszódjon a háttér törlése, és ne hunyorítson
    az ablak.
  

1996.12.04

    Get object-ek sûlyesztése. A get3d.ch-ban a GET3D szimbólum
    definiálásával szabályozható, hogy sûlyesztett, vagy síma
    getek legyenek-e. A fõ nehézség az, hogy a getek mérete
    megnövekszik 2 sorral, ezért a display windowkban nagyobb
    sorközt kell tartani. A puszta TextOut így nem elég az 
    ablak teljes kifestésére, törölni kell a hátteret.
    
    Régi hiba volt, hogy egy popupwindow (browse, achoice, maszk,
    alert) bezárása esetén mielõtt a parent megkapná véglegesen
    a fókuszt, felvillan alatta egy másik programhoz tartozó ablak.
    A jelenség oka az, hogy a láncba fûzött ablakok nem utolsó tagjai
    disablezve vannak, és így a felsõ ablak destroyolásakor egy
    pillanatig nincs az alkalmazásnak enabled ablaka. A felsõ 
    ablak WM_DESTROY-ánál már késõ enablezni a parentet.

    Megoldás:

    1. minden explicit DestroyWindow hívás (Clipper és CPP egyaránt)
       elõtt a parentet enablezni kell.

    2. WM_SYSCOMMAND, SC_CLOSE-ban a parentet enablezni kell.
    
    3. azt hiszem más módon nem szûnik meg ablak.
    

1996.12.02
    DefError()-nak a Clipperhez hasonlóan errorlevel(1),quit-tel
    kell kilépnie, nem pedig break-kel

1996.12.01

    új modulok, függvények

    clpcpfil: filecopy
    clpfpar : filesize,filedate,fileattr,filetime
    clpsys  : diskname
    ntutil  : truename, diskfree

1996.11.30
    Nem lehet generális WM_PAINT kezelõ thread-et csinálni,
    mert egy thread csak a saját ablakainak küldött message-eket
    kapja meg PeekMessage()-bõl.
    
    DevOutPict()-et átvettem a DOS-os kódból, DevOut és DevOutPict
    egyelõre továbbra is csak display window-ba tud írni, ezért nem 
    lehet @ say utasításokkal printelni.

1996.11.28
    Windows-os browse-okba és display-ekbe minimizeboxot raktam.
    A windows-os browse-ok is üres caption helyett mindig a
    DefaultWindowCaption() értékét írják ki, hogy az ikonok ne
    maradjanak felirat nélkül. Egyelõre mindenhol az IDI_APPLICATION
    azonosítójú default ikon jelenik meg.
    
    VIGYáZAT: ikonizálás, visszaállítás, maximalizálás közben
    biztosítani kell, hogy az alul lévõ ablakok ne váltsanak ki
    pozícionálást az adattáblákban.

1996.11.26
    DefError hibás volt.

1996.11.14
    eject kimenete chr(12)+chr(13), 
    így kompatibilis a Clipperrel,
    korábban csak chr(12) volt

1996.11.13
    winapi.cpp-ben új függvény: setfocus()

1996.11.11
    memoedit caption-jébe DefaultWindowCaption()
    memoedit után lastkey() beállítása setlastkey() hívásával

1996.08.29
    SET CONFIRM kezelése
    get:typeOut kezelése


